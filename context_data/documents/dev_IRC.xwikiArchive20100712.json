{"id": "dev:IRC.xwikiArchive20100712", "url": "https://dev.xwiki.org/xwiki/bin/view/IRC/xwikiArchive20100712", "title": "IRC Archive for channel #xwiki - XWiki", "collection": "Eval-Large", "mimetype": "text/markdown", "language": "en", "content": "\nsdumitriu left at 00:08 (Quit: Leaving.  \nflorinciu left at 01:23 (Quit: Leaving.  \nxipe\\_ left at 05:36 (Ping timeout: 240 seconds  \nsburjan joined #xwiki at 08:35  \nmariusbutuc joined #xwiki at 08:35  \nmariusbutuc left at 08:43 (Ping timeout: 276 seconds  \nsilviar joined #xwiki at 09:29  \nlpereira joined #xwiki at 09:31  \nkibahop joined #xwiki at 09:43  \nmflorea joined #xwiki at 09:43  \nsilviar1 joined #xwiki at 09:44  \nsilviar left at 09:45 (Ping timeout: 264 seconds  \nflorinciu joined #xwiki at 09:54  \narkub joined #xwiki at 10:12  \nEnygma` joined #xwiki at 10:13  \nasrfel joined #xwiki at 10:14  \nasrfel left at 10:16 (Client Quit  \nasrfel joined #xwiki at 10:16  \nabusenius joined #xwiki at 10:17  \nCalebJamesDeLisl - (10:24): abusenius: ping when you've got your coffee and you're all ready to chat about crypto.  \nsburjan - (10:26): anyone with some solid xpath knowledge ?  \nCalebJamesDeLisl - (10:28): I have some (not solid) xpath knowledge, what's the question?  \nsburjan - (10:29): I was wondering ifthere is a way to select a specific substring from a <p>. I want to simulate selectnig 3 words from a sentence. With Xpath you can easily select an entire <p>. But i'd need selected only one or 3 words let's say  \nsburjan - (10:30): i was looking on the function list  \nsburjan - (10:30): and I couldnt find something suitable..  \nCalebJamesDeLisl - (10:32): If you have xpather installed in forefox you can play with % and \\* and see if anything works (I don't know).  \nabusenius - (10:32): sburjan: maybe contains?  \nabusenius - (10:32): CalebJamesDeLisl: ping  \nCalebJamesDeLisl - (10:33): Good morning. Did you look at my proposed interface?  \nabusenius - (10:33): good morning, yes  \njvelo joined #xwiki at 10:33  \nabusenius - (10:33): sburjan: example from ui-tests //a[@class='tool delete' and contains(@href, '\" + getUtil().escapeURL(name) + \"')]/img\"  \nabusenius - (10:34): Caleb, I'm not sure it is better to stay away from crypto classes and always use string  \nabusenius - (10:35): crypto classes can always be created from string and converted to string  \nCalebJamesDeLisl - (10:35): I have been thinking about that, I'm thinking maybe the create functions should return X509Certificate.  \nCalebJamesDeLisl - (10:35): []  \nabusenius - (10:36): maybe  \nCalebJamesDeLisl - (10:36): I am pretty sure sign and verify should handle only strings because they most likely to be used with data fresh from the db.  \nabusenius - (10:37): in any case, for signed scripts it is more convenient to use the wrapper classes IMO  \nCalebJamesDeLisl - (10:37): I think we should think more about signed generic text than scripts per se.  \nabusenius - (10:37): they can use generic sign and verify internally, but otherwise they should hide the details completely  \nlpereira left at 10:38 (Read error: Operation timed out  \nCalebJamesDeLisl - (10:39): Another motivation of dealing in strings as much as possible is that it doesn't require the user to hunt down, import and learn additional apis/classes.  \nabusenius - (10:39): and, we need to sign not just the code, but also some additional info, and the format of this data structure should be fxed  \nabusenius - (10:39): well, it is convenient if you have your private key as string and the text you want to sign  \nCalebJamesDeLisl - (10:40): That's why i want sign to be able to sign anything that is a string, the signature macro becomes just a use case, the entire document could be signed if desired.  \nabusenius - (10:41): the XWikiSignature takes byte[] currently, switching to string is not a big deal  \nabusenius - (10:41): and calling it crypto service :)  \nCalebJamesDeLisl - (10:42): I have what I think is a more simple validation mechanism. The user's document is placed in the cert, then you read the cert and get the user document, look in the user document to make sure it actually has the cert and then you know that user signed the text.  \nCalebJamesDeLisl - (10:42): UID=xwiki:XWiki.JohnSmith  \nabusenius - (10:43): we can just use the full user name  \nabusenius - (10:43): and lookup the document  \nCalebJamesDeLisl - (10:44): Hmm, it will fail in a multiwiki environment. I went with using reference serializer.  \nabusenius - (10:44): otherwise it might be tricky, because there is more info in the user doc than we need  \nabusenius - (10:44): if the user changes something we need to decide if its ok  \nabusenius - (10:45): maybe we should only allow global users  \nabusenius - (10:45): ?  \nCalebJamesDeLisl - (10:45): The user puts the X509 in their document and we just look for it.  \nCalebJamesDeLisl - (10:45): aka: FOAFSSL  \nabusenius - (10:45): actually, pkcs7 signature includes the certificate  \nabusenius - (10:46): so we just need to check if its a known one  \nabusenius - (10:46): e.g. from the user doc  \nCalebJamesDeLisl - (10:46): Yes, that's my method.  \nCalebJamesDeLisl - (10:47): We could even throw the sha1 fingerprint in the key object and just compare that to improve performance.  \nCalebJamesDeLisl - (10:47): s/key/cert/  \nevalica joined #xwiki at 10:48  \nabusenius - (10:48): ok, so back to crypto service, it should contain generic crypto methods taking string, some helper methods to convert string representation <-> crypto classes  \nabusenius - (10:48): what else?  \nabusenius - (10:48): base64 should be in another service imo  \nabusenius - (10:49): it is not crypto, just data conversion  \nCalebJamesDeLisl - (10:49): If base64 is going to be a separate component, I think it should be fast and handle streams.  \nabusenius - (10:51): you mean smth like Base64InputStream?  \nCalebJamesDeLisl - (10:51): Sounds right, I havn't seen it.  \nCalebJamesDeLisl - (10:51): Now that I can get firefox to sign data with a key which is trapped in the browser :D \u00a0I'm less motivated to deal with storing private keys on the server.  \nabusenius - (10:52): well, not everyone uses firefox unfortunately  \nCalebJamesDeLisl - (10:52): If we are to store private keys on the server, they need to be in a special document which nobody can read. One case of sql injection and we're burned.  \nabusenius - (10:52): and most people does not give a shit about security  \nabusenius - (10:53): yes, definitely, encrypted  \nCalebJamesDeLisl - (10:54): You make a good point, this is one reason why I am hesitant to work on security for something like IE6 which most likely has keystroke loggers installed etc.  \nCalebJamesDeLisl - (10:54): So you encrypt the private keys? How are they to be decrypted?  \nabusenius - (10:55): user has to give a password  \nCalebJamesDeLisl - (10:55): how often?  \nabusenius - (10:56): btw we can't just ignore ie6 because its ugly, it is the weakest link in the security  \nabusenius - (10:56): well, either every time you sign or with some timeout, like sudo  \nabusenius - (10:56): depends on the application  \nCalebJamesDeLisl - (10:57): I don't ant to ignore it because it's ugly, I want to ignore it because it probably already has trojans and in such a case there is no way to win.  \nabusenius - (10:57): for signed scripts I'd say every time  \nCalebJamesDeLisl - (10:58): Always a tradeoff, ask for passwords too often, get phished.  \nabusenius - (10:58): well, PR should be used as rarely as possible anyway  \nCalebJamesDeLisl - (10:59): Did I mention the \"killer app\" use case for browser keys and sign text? You can authenticate users by passing them a random string and asking them to sign it instead of passing a passoword.  \nabusenius - (11:00): yes you did  \nCalebJamesDeLisl - (11:01): I think the signature macro has uses beyond PR. I imagine a green stripe over a comment or piece of text saying that the user signed it.  \nabusenius - (11:02): yea, some people like to sign every mail they send  \nCalebJamesDeLisl - (11:02): :)  \nabusenius - (11:02): but thats lower priority  \nCalebJamesDeLisl - (11:02): Oh another use case:  \nCalebJamesDeLisl - (11:03): Users give cc# bank info etc.  \nCalebJamesDeLisl - (11:03): Information is encrypted with a public key.  \nCalebJamesDeLisl - (11:03): Sotred in the db.  \nCalebJamesDeLisl - (11:03): When they make an order, the info is sent in an email to a computer which has the private key.  \nCalebJamesDeLisl - (11:04): It doesn't matter how badly the server gets owned, that info is safe.  \nabusenius - (11:04): yea, right, once the crypto api is there, we can write an app that stores everything encrypted  \nCalebJamesDeLisl - (11:04): user's email addresses perhaps.  \nabusenius - (11:05): how about this:  \nCalebJamesDeLisl - (11:05): There's no real point in encrypting something (IMO) unless the private key for decrypting is only stored on a separate machine.  \nabusenius - (11:06): we encrypt important data with the system key, which is stored encrypted and the admin has to enter the password on server start  \nabusenius - (11:06): the decrypted info is not stored in the db  \nabusenius - (11:06): so sql injections cant work  \nabusenius - (11:07): only if you get admin you can access the corresponding api  \nCalebJamesDeLisl - (11:07): Admins don't enter passwords when the server starts, the passwords go in init files.  \nCalebJamesDeLisl - (11:08): However that idea would raise the bar for attacks.  \nabusenius - (11:09): anyway, what else does the crypto service need to do?  \nCalebJamesDeLisl - (11:09): So if the xcontext says I am userX then I am trusted with userX's private keys?  \nabusenius - (11:10): the keys are encrypted, so you should also know the password if you want to use them  \nCalebJamesDeLisl - (11:11): If you are going to store them encrypted then you probably don't have to bother with the root key and all that.  \nabusenius - (11:12): I have thought about that, maybe  \nCalebJamesDeLisl - (11:12): IMO crypto service should facilitate creation of browser keys, and make it possible to encrypt text and validate signatures. That's it.  \nabusenius - (11:13): we can also include several certificates from every committerr, that are trusted by default  \nabusenius - (11:13): (instead of one xwiki key)  \nabusenius - (11:13): s(key/cert/  \nCalebJamesDeLisl - (11:14): Just have a set of cert XObjects attached to a XWikiCommitter user?  \nCalebJamesDeLisl - (11:15): I understand it is possible to sign text with IE but I have to look in to it.  \nkibahop left #xwiki at 11:15  \nabusenius - (11:17): hm, we could make a small web of trust inside of xwiki :)  \nabusenius - (11:17): mutually sign all committer's certs  \nCalebJamesDeLisl - (11:18): Don't need to sign them, just include them in the Committer user.  \nCalebJamesDeLisl - (11:19): Signing is limited because you alter the cert, and after you sign you need revocation lists to \"unsign\". changing users permissions or removing keys is easy.  \nabusenius - (11:19): yes, if all certificates are self-signed and handled the same way its easier I guess  \nCalebJamesDeLisl - (11:20): Well technically they are not self signed but that's just to get over a limitation in ff.  \nCalebJamesDeLisl - (11:21): One other thing which you can do with crypto is specify what private key and cert each client cert will be signed with.  \nCalebJamesDeLisl - (11:22): By default it creates a CA cert on the fly for each user who makes a key.  \nabusenius - (11:22): do you mean ff api?  \nCalebJamesDeLisl - (11:23): firefox refuses to sign with a key unless that key is signed by a trusted CA.  \nCalebJamesDeLisl - (11:24): So by default it will create a CA per user and then after they have created the key it can use some javascript to download the CA and they will get the popup which asks them to trust the CA.  \nCalebJamesDeLisl - (11:25): I;m imagining a wizard which walks them through the process.  \nCalebJamesDeLisl - (11:26): However if you specify the CA cert which will sign their user keys, it can also sign the server key, and then users can have ssl without the admin having to pay da man for a cert.  \nabusenius - (11:26): ah, ok, nice  \nCalebJamesDeLisl - (11:27): I was thinking it would be neat to have a little piece of js which loads from the https server and the js redirects to the https page \\*if it loads\\*.  \nCalebJamesDeLisl - (11:28): My main concern is that crypto contains as few lines of code as possible.  \nCalebJamesDeLisl - (11:29): Anything which doesn't have to be trusted should go somewhere else.  \nCalebJamesDeLisl - (11:31): What do you think of getting browser keys working before starting on server side keys? We have enough apis right?  \nabusenius - (11:32): we can do both in parallel actually  \nabusenius - (11:32): just need to update the crpto service interface a bit  \nabusenius - (11:34): (remove base64, use crypto classes to sign etc, add converter text <-> crypto classes)  \nCalebJamesDeLisl - (11:34): There is a server side crypto.signText.  \nCalebJamesDeLisl - (11:35): Where are you expecting to get the key from when you sign text?  \nabusenius - (11:36): whoever uses this api should have it :) e.g. signed macros will have a server side storage  \nabusenius - (11:37): if you have your key in browser, you'll never need to use this method  \nCalebJamesDeLisl - (11:37): So from a memory cache or from a text element in the db?  \nabusenius - (11:37): yes  \nCalebJamesDeLisl - (11:38): If it's from the db then you'll want it to take a String.  \nabusenius - (11:38): I won't use the data from db directly  \nabusenius - (11:38): it needs to be decrypted first anyway  \nCalebJamesDeLisl - (11:39): How will you be encrypting it?  \nabusenius - (11:40): pkcs8 supports encryption afaik  \nabusenius - (11:40): so I'd ask the user for password when needed  \nCalebJamesDeLisl - (11:41): I understand pkcs8 is the recommended way to encrypt a private key.  \nCalebJamesDeLisl - (11:41): So you'll need symmetrical encryption/decryption api functions.  \nabusenius - (11:42): probably  \nabusenius - (11:42): I'm not sure if I need to encrypt it by myself  \nabusenius - (11:43): maybe there is some method in private key to do it  \nCalebJamesDeLisl - (11:43): I added a function for getting a KeyPair but it returns just that.  \nCalebJamesDeLisl - (11:44): Actually I liked you're KeyPair wrapper, it seems that X509CertAndPrivateKey is missing from bouncycastle.  \nCalebJamesDeLisl - (11:44): So we can have a function to return one of those.  \nabusenius - (11:45): I think those wrapper are handy for scripting, default PrivateKey interfaces are too java-oriented  \nabusenius - (11:46): maybe we can use them instead of directly using X509Cerificates etc.?  \nCalebJamesDeLisl - (11:47): I think it's easy to overuse wrappers and end up rewriting everything. IMO a wrapper should on;y be used when the original class is deficient.  \nCalebJamesDeLisl - (11:47): XWikiCertificate is a wrapper which i don't see the justification for.  \nabusenius - (11:48): simpler use  \nabusenius - (11:48): X509cert doesn't have fingerprint  \nabusenius - (11:49): it doesn't have a method to export in PEM format  \nCalebJamesDeLisl - (11:49): Maybe just extend it and add those functions?  \nabusenius - (11:51): well, x509cert is an abstract class, and the real implementations are not known  \nabusenius - (11:51): they come from some internal package in bc  \nabusenius - (11:51): or elsewehre if you use another provider  \nabusenius - (11:53): I could extend the class but still wrap the real implementation tough  \nCalebJamesDeLisl - (11:54): It only makes sense if it can be casted back and forth.  \nabusenius - (11:55): why? just use getCert() and you have your X509  \nCalebJamesDeLisl - (11:55): Then there's no point in making it extend X509.  \nabusenius - (11:55): my idea was to use the wrapper everywhere  \nCalebJamesDeLisl - (11:56): One of the reasons for my resistance to wrappers is that I always find myself unwrapping them all everytime I try to do something.  \nabusenius - (11:57): I think in this case it should be fine, the only thing you can really do with certificates is to verify something  \nabusenius - (11:58): so if the verify method takes the wrapper, you'll never need x509  \nCalebJamesDeLisl - (11:58): If there's anything you want to do using bouncycastle libraries or java.security, you're going to need X509s.  \nCalebJamesDeLisl - (11:58): That has been said before.  \nabusenius - (11:58): but its internal thing  \nabusenius - (11:58): why do you want to expose x509 to scripts for example?  \nabusenius - (11:59): it has many methods you can't even use there  \nCalebJamesDeLisl - (11:59): In the case of groovy, the script can load bc libraries and do all sorts of things.  \nabusenius - (12:00): well, there you can create your own x509  \nCalebJamesDeLisl - (12:01): You'll probably be using a cert which is stored on the system.  \nabusenius - (12:01): x509 is too feature-rich, Certificate has all the methods we need except for CN and CA  \nabusenius - (12:02): and X509Certificate adds 20+ more methods  \nCalebJamesDeLisl - (12:02): too feature rich?  \nabusenius - (12:03): too many unneeded methods  \nCalebJamesDeLisl - (12:03): Well they must be there for some reason.  \nabusenius - (12:04): they are in the x509 standard, but I don't see why we would need to use them  \nCalebJamesDeLisl - (12:04): Another point is the crypto service should not just be a script service, it should be exposed to all components.  \nCalebJamesDeLisl - (12:05): Perhaps a wrapper should be written to smooth over issues specific to velocity for the script service.  \nCalebJamesDeLisl - (12:05): ^ Like to avoid even that if possible.  \nabusenius - (12:06): actually, all java crypto methods use Certificate  \nabusenius - (12:06): X509 is really only needed to get the name out  \nabusenius - (12:07): I don't want to require x509 everywhere just because I need the name  \nabusenius - (12:07): (CN)  \nCalebJamesDeLisl - (12:07): There's no way to get the CN from a Certificate?  \nabusenius - (12:08): I couldn't fine one  \nCalebJamesDeLisl - (12:09): Hmm. That's not good for my validation method.  \nabusenius - (12:11): hm, CMSSignedDataGenerator also wants x509 certificate  \nCalebJamesDeLisl - (12:11): Ok. validateText should not be requiring a cert at all, the cert is provided in the signature.  \nabusenius - (12:16): hm, maybe I should make XWikiCertificate extend Certificate, and wrap a X509 cert  \nabusenius - (12:17): XWikiCertificate can be used as is in most of the cases then, and if you really need x509 you can get it  \nabusenius - (12:17): + helper methods are still there  \nCalebJamesDeLisl - (12:17): Doesn't help much, cms encryption requires an X509 too.  \nCalebJamesDeLisl - (12:18): What are we getting by wrapping x509?  \nabusenius - (12:18): fingerprint  \nabusenius - (12:19): encoding  \nabusenius - (12:19): decoding  \nCalebJamesDeLisl - (12:19): What's fingerprint used for?  \nabusenius - (12:19): in signed scripts to find the certificate in the storage  \nCalebJamesDeLisl - (12:20): You don't have to do that if the certs say the mane of the user to whom they belong.  \nCalebJamesDeLisl - (12:21): s/mane/name/  \nabusenius - (12:21): verify() can automatically lookup in the storage if the cert is trusted or npt  \nabusenius - (12:21): but then I need to require that the browser generated certs have the same name  \nCalebJamesDeLisl - (12:22): The browser only generates the private key, the server does everything else.  \nabusenius - (12:22): ok  \nabusenius - (12:22): still, I trust the fingerprint more than some name  \nCalebJamesDeLisl - (12:22): Suppose you have XWikiX509Certificate extends X509 and the constructor takes an X509?  \nCalebJamesDeLisl - (12:23): You have to use both.  \nabusenius - (12:23): it is easy to generate another cert with the same name, but almost impossible to produce the same fingerprint  \nCalebJamesDeLisl - (12:23): Or you have to look at the user's document and make sure the cert resides there.  \nCalebJamesDeLisl - (12:23): the name in the cert is just a pointer to know where to look.  \nCalebJamesDeLisl - (12:24): You can extend X509 and have every function be passed on to the wrapped X509.  \nCalebJamesDeLisl - (12:25): Just like a BufferedReader.  \nCalebJamesDeLisl - (12:26): That's also how $request works.  \nabusenius - (12:26): I don't see why this is better than getCert()  \nabusenius - (12:26): it is way less code  \nabusenius - (12:27): and will not be used in 99% of cases  \nCalebJamesDeLisl - (12:27): Where do you expect to return and require this cert wrapper?  \nabusenius - (12:27): everywhere  \nabusenius - (12:28): no x509 at all, only if some implementation really needs it  \nabusenius - (12:28): (like pkcs7 signature)  \nCalebJamesDeLisl - (12:28): You're sure that you thought this out better than the java people?  \nabusenius - (12:29): no, that's why I'll extend Certificate  \nabusenius - (12:29): but not x509certificate, it's an implementation  \nCalebJamesDeLisl - (12:29): So is Certificate.  \nabusenius - (12:30): Certificate is the base class used everywhere  \nCalebJamesDeLisl - (12:30): Except signing and encryption.  \nabusenius - (12:30): they use private/public key  \nabusenius - (12:30): and cert has the corresponding methods  \nabusenius - (12:31): pkcs7 signature is a very specific use case  \nabusenius - (12:31): it has to use x509 because the standard says so  \nCalebJamesDeLisl - (12:31): And cms encryption...  \nabusenius - (12:32): again, thats only because they include a x509 cert  \nCalebJamesDeLisl - (12:32): Will your cert be able to be constructed from a non x509 cert?  \nabusenius - (12:32): normal Signature does not require that  \nlucaa joined #xwiki at 12:32  \nabusenius - (12:33): no (at least now), but it can be constructed from another type of certificate if it supports name  \nCalebJamesDeLisl - (12:33): So it is indeed an X509.  \nabusenius - (12:33): in any case it can be extended to support another certificates without changes to the rest of the code  \nabusenius - (12:34): I see it as a generic wrapper  \nabusenius - (12:35): but you make a point, it is very x509-like  \nCalebJamesDeLisl - (12:36): If we support a non x509, then somebody wraps a non x509, then passes the wrapper to signText what happens?  \nabusenius - (12:37): it wont work I guess  \nabusenius - (12:38): ok, you convinced me :) I'l extend x509  \njvelo left at 12:40 (Ping timeout: 265 seconds  \nCalebJamesDeLisl - (12:42): Can copy paste from here: http://svn.apache.org/repos/asf/harmony/enhanced/archive/classlib/java6/modules/security/src/main/java/common/java/security/cert/X509Certificate.java  \nCalebJamesDeLisl - (12:46): I would avoid extending verify since it's hard to know when that might get called.  \nabusenius - (12:49): I have to, its abstract  \nlucaa left at 12:50 (Ping timeout: 276 seconds  \nabusenius - (12:52): yea, fanout violation -\\_-  \nCalebJamesDeLisl - (12:52): Just make it call the wrapper rather than having it do any thing special.  \nlucaa joined #xwiki at 12:53  \nCalebJamesDeLisl - (12:53): I just committed (non-working) xwiki-crypto, you might be interested in ConversionUtils.java  \nabusenius - (12:54): I do, it still has 26 imports  \nCalebJamesDeLisl - (12:54): WrappingX509Certificate extends X509Certificate  \nCalebJamesDeLisl - (12:54): XWikiX509Certificate extends WrappingX509Certificate  \nCalebJamesDeLisl - (12:55): That would also be nice to separate your changes from the boiler plate wrapping code.  \nabusenius - (12:56): right  \nCalebJamesDeLisl - (12:57): ConversionUtils#getBase64Encoded has the cool 65 character line break making the PEM stuff look legit.  \nCalebJamesDeLisl - (13:06): if (cert instanceof WrappingX509Certificate) { this.wrappedCert = cert.wrappedCert; }  \nCalebJamesDeLisl - (13:07): That way you won't end up wrapping a cert more than once.  \nCalebJamesDeLisl - (13:07): \\* Doesn't matter if wrappedCert is private because it's in the same class.  \nlucaa left at 13:32 (Ping timeout: 252 seconds  \nCalebJamesDeLisl - (13:54): Suppose the signature was used not only for PR content but for an XObject which was put in a user's document which granted them a privilege?  \nabusenius - (13:58): do you mean the object that gives some privilege needs to be signed?  \nCalebJamesDeLisl - (13:59): yup. Then you check who signed it and see if they have the privilege.  \nCalebJamesDeLisl - (14:01): Represent the privileges in the user page using xml.  \nCalebJamesDeLisl - (14:01): The admin of wikiX can grant privileges to the users of wikiY.  \nCalebJamesDeLisl - (14:02): bblfish would like the sound of that.  \nabusenius - (14:04): hm, not sure it makes a lot of difference  \nCalebJamesDeLisl - (14:04): Why not?  \nabusenius - (14:05): well, if we just use one signed object that gives say edit rights, then what is the difference to having a not signed object doing the same?  \nabusenius - (14:06): the reason to have certificates for pr is that pr needs to be delegated to a piece of code  \nCalebJamesDeLisl - (14:07): With the unsigned object the validator will fail.  \nCalebJamesDeLisl - (14:07): With the signed object, the validator will check who signed it and see if they have the permission.  \nabusenius - (14:07): but in the case of given a right to user you can just have a table in the db and everything will be fine  \nabusenius - (14:08): no need to check the permission, only those \u00a0who have permission can write to that table  \nCalebJamesDeLisl - (14:08): But if someone sneaks an insert into that table, BOOM.  \nabusenius - (14:08): well, you can read the secret key in the same way  \nabusenius - (14:09): what I'm trying to say is that we should try to not overcomplicate simple things just because certs are so cool :)  \nCalebJamesDeLisl - (14:09): The signed permission would say \"I Caleb give you Alex programming rights on this wiki\" <signature>  \nCalebJamesDeLisl - (14:09): Nobody but you can use it.  \nCalebJamesDeLisl - (14:10): hmm, nonrevokable.  \nabusenius - (14:10): unless he has a user with the same name  \nCalebJamesDeLisl - (14:10): fingerprint.  \nabusenius - (14:10): of what?  \nCalebJamesDeLisl - (14:10): your cert.  \nabusenius - (14:10): ah, ok  \nabusenius - (14:11): hm, still, why so complicated?  \nabusenius - (14:11): if the server is compromised we are all doomed anyway  \nCalebJamesDeLisl - (14:12): What's neat is you can put one cert in a read only file. That's the admin's cert. With that there is \\_no way\\_ to get PR without convincing someone to give it to you.  \nabusenius - (14:13): which is the easiest way to get it btw :)  \nabusenius - (14:13): (csrf)  \nCalebJamesDeLisl - (14:13): Well crypto.signText isn't easy to fool. The user has to see the popup and click yes.  \nabusenius - (14:14): with pr it might be worth it, it is a very dangerous right  \nabusenius - (14:14): but for everything else?  \nabusenius - (14:14): signature for comment right? come on..  \nCalebJamesDeLisl - (14:14): That's my thinking. For everything else, the infrastructure is there, why not?  \nCalebJamesDeLisl - (14:15): comment permission lol.  \nCalebJamesDeLisl - (14:16): If you admin a wiki, you can give users of another wiki certan benefits by giving those benefits to the other wiki's admin.  \nabusenius - (14:17): I don't know, it sounds too fancy for the real use cases  \nCalebJamesDeLisl - (14:17): I think it is actually very simple as far as the code goes..  \nabusenius - (14:18): still, we would need to rewrite even more code  \nCalebJamesDeLisl - (14:19): RightsManager needs to be rewritten and I'm for it being as short as possible.  \nabusenius - (14:19): and another problem, if we sign user cert in those permission objects, then we need to hide the cert  \nabusenius - (14:19): otherwise somebody could copy it to his own user  \nCalebJamesDeLisl - (14:20): No. It's like a check, it's written to you and only you.  \nabusenius - (14:20): what can be shorter than selelect count(\\*) from documents where document.name = user && rights == bla?  \nCalebJamesDeLisl - (14:21): '); or 1=1  \nabusenius - (14:21): rights are not user input  \nabusenius - (14:21): and the query should be parametriezed  \nCalebJamesDeLisl - (14:22): \\_should\\_  \nCalebJamesDeLisl - (14:23): I got to thinking about this because there is the problem that someone might install another cert in my user page.  \nabusenius - (14:23): well, using an overcomplicated method because we might have a bug in that one line is stupid  \nabusenius - (14:24): I don't like the idea of putting everything into user docs at all  \nCalebJamesDeLisl - (14:24): Then where would you put the certs?  \nabusenius - (14:24): things like passwords should \\*not\\* be there  \nCalebJamesDeLisl - (14:25): cert = public key, not sensitive.  \nabusenius - (14:25): I'm not sure yet, into a special DB table, whatever  \nabusenius - (14:25): there should be no API for viewing those data  \nCalebJamesDeLisl - (14:25): Why not for viewing certs?  \nabusenius - (14:26): for certs ok  \nabusenius - (14:26): I mean keys  \nCalebJamesDeLisl - (14:27): We can't change the schema for private keys. The best you can do is create a special document which almost nobody can view.  \nabusenius - (14:27): why can't we add a secure storage?  \nabusenius - (14:27): which is not a document?  \nCalebJamesDeLisl - (14:28): because there is no such thing as secure storage on the internet.  \nabusenius - (14:28): on the server  \nCalebJamesDeLisl - (14:28): And it would change the schema.  \nabusenius - (14:29): we should at least have a dedicated document for that  \nabusenius - (14:29): which nobody can view  \nCalebJamesDeLisl - (14:29): \\*almost nobody  \nabusenius - (14:30): no, really nobody  \nCalebJamesDeLisl - (14:30): Then export will be fun.  \nabusenius - (14:30): only the special API for keys should be do it  \nabusenius - (14:30): export is another thing  \nCalebJamesDeLisl - (14:30): Non-point since admin right trumps all.  \nCalebJamesDeLisl - (14:31): So where would you put the certs since they aren't really sensitive.  \nabusenius - (14:31): keys are exported only when the whole wiki is exported, why not have a special handling for them?  \nabusenius - (14:32): the certs can be in user pages, but only for convenience  \nabusenius - (14:32): the mapping user - fingerprint should be stored together with the keys  \nCalebJamesDeLisl - (14:33): The problem is what happens if a wise guy adds his own cert to the user document of an admin.  \nabusenius - (14:33): it doesn't matter  \nabusenius - (14:33): the mapping is what matters  \nCalebJamesDeLisl - (14:33): Now he can use his private key to pretend to be that admin.  \nabusenius - (14:33): if the mapping says admin has cert x and he has cert y in the user doc, its an error  \nCalebJamesDeLisl - (14:34): What will check the mapping?  \nabusenius - (14:34): the verification method  \nabusenius - (14:35): if you verify a signature, you should check not the user doc, but the mapping  \nCalebJamesDeLisl - (14:35): so you're going to add private storage logic to crypto api?  \nCalebJamesDeLisl - (14:35): \\*private key storage logic  \nabusenius - (14:35): it should probably be another component  \nCalebJamesDeLisl - (14:36): getting complicated...  \nabusenius - (14:36): I'm not sure what is the best way to do it  \nabusenius - (14:37): but I'm sure misusing user docs is definitiely not the best way  \nCalebJamesDeLisl - (14:37): The best way is to leave the key in the browser. Anything else is a compromise.  \nabusenius - (14:37): thats only an option  \nabusenius - (14:38): admit it, ff is not the most common browser yet  \nCalebJamesDeLisl - (14:38): what?  \nCalebJamesDeLisl - (14:38): http://www.w3schools.com/browsers/browsers\\_stats.asp  \nabusenius - (14:38): I mean among normal people, not us :)  \nabusenius - (14:40): and, how many committers do you think will leave the key in browser? :)  \nCalebJamesDeLisl - (14:41): It doesn't matter to me, I just want to provide the tools to be secure if you want. \u00a043% to chrome's 15.7 is a definite majority.  \nabusenius - (14:41): it is important for sure  \nabusenius - (14:42): but if you leave 10% of people insecure, thats who will be hacked  \nabusenius - (14:42): just because its easier  \nCalebJamesDeLisl - (14:43): People neglect due diligence all the time because it's easier, they are not my main concern.  \nCalebJamesDeLisl - (14:43): I can provide the tools, I can make it reasonably easy to use, I can't do it for them.  \nabusenius - (14:45): thats not sufficient, the default case is the one that really matters  \nCalebJamesDeLisl - (14:45): My point is we can have almost perfect security if the key stays in the browser, I think we should not sacrifice a bit of that security for a system which will never be as secure.  \nabusenius - (14:45): it should be (sufficiently) secure by default, if the user don't care, they should be forced to be secure  \nabusenius - (14:46): and if the user cares, he should have a choice  \nCalebJamesDeLisl - (14:46): I think we will have a difference of opinion then because I believe the user is the boss and we can't (and shouldn't) force them to do anything.  \nabusenius - (14:46): probably  \nabusenius - (14:47): I also don't like to be forced to use something  \nabusenius - (14:47): because I know better  \nabusenius - (14:48): but on the other hand, most other people don't care  \nCalebJamesDeLisl - (14:48): It's a very old question, on one side you have microsoft who knows what you need and is going to give it to you, on the other hand you have linux which has the humility to admit it doesn't know what you need and will give you what you ask for.  \nabusenius - (14:49): I'd prefer a compromise  \nabusenius - (14:49): ubuntu tries to do one  \nabusenius - (14:50): it should be good enough for ordinary people, and customizable for the rest  \nabusenius - (14:50): but it is harder to do  \nabusenius - (14:51): ok, lets stop the flamewar :)  \nCalebJamesDeLisl - (14:51): The question you have to ask is: \"is it better to be anger a few smart people or inconvenience a lot of dumb people?\"  \nCalebJamesDeLisl - (14:51): Not a flamewar, this is an important philosophical question.  \nnickless joined #xwiki at 14:55  \nnickless - (14:55): it depends :)  \nnickless - (14:55): if the smart people are getting hacked because the dumb people don't care, they should better accept the inconvenience  \nabusenius left at 14:56 (Ping timeout: 265 seconds  \nnickless is now known as abusenius ([[email\u00a0protected]](https://dev.xwiki.org/cdn-cgi/l/email-protection)  \nCalebJamesDeLisl - (14:56): in response to which?  \nCalebJamesDeLisl - (14:56): Oh, I see.  \nCalebJamesDeLisl - (14:57): How do you imagine the one man's incompetence leading to another getting their system broken?  \nabusenius - (14:58): say you have 20 people who have the acces to something important  \nabusenius - (14:58): the default setting is insecure, and you need to set up something to get the job done  \nabusenius - (14:59): if 3 people care, and have the knowledge, they will secure their accounts  \nabusenius - (14:59): they will not be hacked, but somebody of the other 17 can be  \nabusenius - (15:00): so the whole system is owned anyway because of the weakest link  \nabusenius - (15:00): if we make the average more secure, the weakest link will be more secure  \nCalebJamesDeLisl - (15:00): Well maybe the admin is smart and only trusts the 3 with PR.  \nabusenius - (15:01): hopefully :)  \nCalebJamesDeLisl - (15:01): If the admin is a fool then we certainly can't help anyone.  \nabusenius - (15:01): but I don't expect and average admin to care a lot  \nabusenius - (15:01): we can  \nabusenius - (15:02): we write the system  \nCalebJamesDeLisl - (15:02): We lock the admin out :D  \nabusenius - (15:02): if we make it secure by default, the admin will need to disable security, which is really his fault  \nCalebJamesDeLisl - (15:03): \"secure by default\" is a marketing term, what do you mean by \"secure by default\"?  \nabusenius - (15:04): well, if you have several settings that make xwiki more or less secure, the default should be secure  \nabusenius - (15:04): e.g. bind to ip  \nCalebJamesDeLisl - (15:05): Most settings are trade offs, what are we going to trade?  \nCalebJamesDeLisl - (15:06): upgradabulity?  \nabusenius - (15:06): well, it is easier said than done, but we need to try to make it as secure as possible, but usable  \nabusenius - (15:06): no, this is important for security too  \nabusenius - (15:07): complicated upgrade stops people from using new versions  \nCalebJamesDeLisl - (15:07): Another point is these keys are basically a toy for the moment because if we disable the current PR system then upgrades will be impossible.  \nabusenius - (15:08): why impossible?  \nabusenius - (15:08): they will not be worse than now  \nCalebJamesDeLisl - (15:08): If every line of pr has to be signed to run? All pr in the wiki will break.  \nabusenius - (15:09): it depends on who wrote that code  \nabusenius - (15:09): all the code from xwiki will run  \nCalebJamesDeLisl - (15:09): Well nothing is signed in legacy systems.  \nabusenius - (15:10): and the code the admins added will need to be signed  \nCalebJamesDeLisl - (15:10): You can propose that ;)  \nabusenius - (15:10): yes, thats why there is also the idea for PR administration GUI  \nCalebJamesDeLisl - (15:11): complicated complicated complicated...  \nabusenius - (15:11): signed code is the tool to make it better  \nabusenius - (15:11): it will ensure pr will never break again  \nabusenius - (15:11): admin gui is for the upgrade  \nCalebJamesDeLisl - (15:11): So we were talking about an implementation problem at one point.  \nabusenius - (15:12): yes  \nCalebJamesDeLisl - (15:12): How does the crypto.validateText function work?  \nabusenius - (15:13): it just validates the text you give it?  \nabusenius - (15:13): you give the text and the key, it validates  \nCalebJamesDeLisl - (15:13): It can check the cert in the signature and look at the user page of the user holding the cert, then it can make sure that user actually has that cert on their user page.  \nCalebJamesDeLisl - (15:14): Then return the name of that user.  \nCalebJamesDeLisl - (15:14): But I can make an arbitrary cert with your name and sign stuff with it if I can figure out how to get it attached to your user page.  \nabusenius - (15:15): thats why I want to have a central place where the valid/known certificates are stored  \nCalebJamesDeLisl - (15:16): and crypto.validateText will then have to know about this place.  \nabusenius - (15:16): there is also another example, lets say you delete that user  \nabusenius - (15:16): the certificate should not be deleted  \nCalebJamesDeLisl - (15:16): Why not?  \nabusenius - (15:17): because everything that user wrote will break  \nCalebJamesDeLisl - (15:17): Well deleting a user is kind of like taking away all of their permissions and all of the permissions they deligated to scripts.  \nabusenius - (15:18): why?  \nCalebJamesDeLisl - (15:18): Why would you delete a user if you wanted his scripts to continue to work?  \nCalebJamesDeLisl - (15:18): friendly kickban?  \nabusenius - (15:18): because they should, if the user is not there, he cannot login any more, by why should it affect old content?  \nabusenius - (15:19): you don't delete the content of pages he wrote, why should the scripts stop working?  \nCalebJamesDeLisl - (15:19): Because it's his permission which he deligated to the scripts, delete the user, delete the permission.  \nabusenius - (15:20): this is how it works now  \nabusenius - (15:20): signed code becomes independant  \nCalebJamesDeLisl - (15:20): If the goal is to prevent a user from logging in, deleting the user page seems like the wrong action.  \nabusenius - (15:21): the user gives pr to the script in the moment he writes it  \nCalebJamesDeLisl - (15:21): the user gives \\_his\\_ pr to the script.  \nabusenius - (15:22): so if the user is denied pr, deleted, dies, whatever, scripts should still work unless the admin does not want it  \nabusenius - (15:22): yes, he ives the pr, not the pointer to pr :)  \nabusenius - (15:22): \\*gives  \nabusenius - (15:23): otherwise we will need to keep users in the system for scripts to work  \nCalebJamesDeLisl - (15:23): Did you end up watching the video about security through lazyness?  \nabusenius - (15:23): we cannot copy pr scripts somewhere else  \nabusenius - (15:23): yes :)  \nCalebJamesDeLisl - (15:24): So I suppose you can see where I'm coming from with all of this revocable permission nonsense.  \nCalebJamesDeLisl - (15:25): You can copy a PR script but you will have to resign it or grant permission to the user who signed it.  \nabusenius - (15:25): its not nonsense, its reality  \nabusenius - (15:25): undenyable pr is bad  \nCalebJamesDeLisl - (15:26): hmm?  \nabusenius - (15:26): the only way to deny pr is to delete the user and resign all scripts?  \nabusenius - (15:26): isn't it a bit strange?  \nabusenius - (15:26): and inconvenient?  \nCalebJamesDeLisl - (15:27): Good point. You could revoke PR but the scripts would still have to be resigned.  \nabusenius - (15:27): ok, maybe I should say that I'm trying to think about PR differently  \nabusenius - (15:28): I think the current way it is handled is totally unintuitive and should be changed  \nCalebJamesDeLisl - (15:28): Of course you could get a list of signed scripts by that user and they would be relitively easy to resign.  \nabusenius - (15:28): my idea is that new PR != old PR  \nabusenius - (15:29): user having new PR == user has the right to sign  \nCalebJamesDeLisl - (15:29): The current way has one advantage that it doesn't get in your way if you are not an expert.  \nabusenius - (15:29): code having new PR == code can access privileged API  \nabusenius - (15:29): the old PR was mixing both rignts badly  \nabusenius - (15:30): but it does get in your way if you administer a wiki  \nabusenius - (15:30): and then you are forced to an expert  \nabusenius - (15:30): just look at the mailing list  \nCalebJamesDeLisl - (15:30): I don't see why a user shouldn't be allowed to sign without PR.  \nabusenius - (15:30): the questions about pr are usually \"oh I have upgraded and then the search suddenly doesn't work\"  \nCalebJamesDeLisl - (15:31): Yea because it's easier to write a PR page than propose API changes.  \nabusenius - (15:31): the answer is as intuitive as \"open that page jump 3 times, sign the sond <link> and resave the page at midnight\"  \nabusenius - (15:31): \\*song  \nabusenius - (15:31): he is not  \nabusenius - (15:32): PR == right to sing, NOT to execute  \nabusenius - (15:32): s/sing/sign/  \nCalebJamesDeLisl - (15:32): Why can't a non pr user sign a page?  \nabusenius - (15:32): I mean sign in a way that gives PR  \nabusenius - (15:33): you can sign it just for fun, but it will not give PR  \nCalebJamesDeLisl - (15:33): Ok.  \nabusenius - (15:33): (PR certificates are registered by the admin)  \nCalebJamesDeLisl - (15:33): Still I see the argument for signatures as weak if the private keys are stored on the same server.  \nabusenius - (15:34): yours will not :)  \nabusenius - (15:34): be happy :)  \nabusenius - (15:34): if the server is owned, what is the difference?  \nabusenius - (15:35): (assuming the certificate was only used on tha server)  \nCalebJamesDeLisl - (15:35): I'll be happy when I know that verifyText will not be looking up any secret documents and hooking other components.  \nabusenius - (15:36): it needs to check if yours certificate is trusted  \nabusenius - (15:36): nothing else  \nabusenius - (15:36): otherwise how will we know if it is you?  \nCalebJamesDeLisl - (15:36): why does it need to know if my cert is trusted? Isn't it enough to know that it's mine?  \nabusenius - (15:37): how do you imagine the process of admin given PR to you?  \nabusenius - (15:37): giving  \nabusenius - (15:37): he checks the box, then you will be asked to provide your cert  \nabusenius - (15:38): you upload  \nabusenius - (15:38): what if somebody changes this certificate afterwards?  \nCalebJamesDeLisl - (15:38): He gets my cert from my user page and makes a permission object which has my cert's fingerprint and puts the object in my user page.  \nabusenius - (15:39): if admin denies PR to you, does it requires to delete your certificate?  \nabusenius - (15:39): hm, ok  \nCalebJamesDeLisl - (15:39): Maybe the permission object says \"Caleb has permission as long as admin's page says '12345' \"  \nabusenius - (15:40): there the permission object makes sense  \nCalebJamesDeLisl - (15:41): And then verifyText becomes very simple because it only needs to return the cert's fingerprint to be checked.  \nabusenius - (15:41): I don't like to store stuff in the user page, but I guess that is the easiest way to do it (at least for now)  \nCalebJamesDeLisl - (15:41): It's not sensitive data.  \nabusenius - (15:42): well, private keys needs to be stored somewhere too  \nCalebJamesDeLisl - (15:42): browser ;)  \nabusenius - (15:43): private keys of most of the users :)  \nCalebJamesDeLisl - (15:43): IMO we can wait on server side private keys because this isn't all going to happen over night anyway.  \nabusenius - (15:45): I suggest you implement the keys in browser, I implement the server side, then we are both happy :)  \nCalebJamesDeLisl - (15:45): When I sign up to a site my biggest trouble is picking a password, I think being able to install a key with 4 clicks will make things easier for many people.  \nCalebJamesDeLisl - (15:46): So you're happy with the verifyText function only returning an X509Cert and making it the implementor's job to determine who's cert that is and what that means?  \nabusenius - (15:47): yes  \nabusenius - (15:47): XWikiCertificate would be better  \nabusenius - (15:47): it implements X509  \nCalebJamesDeLisl - (15:47): Ok, crypto stays small and I'm happy.  \nabusenius - (15:47): great :)  \nCalebJamesDeLisl - (15:48): Right I will return XWikiX509 whereever possible since it has all of the benefits + some.  \nCalebJamesDeLisl - (15:48): Are you planning on naming it XWikiX509Certificate since it extends X509?  \nabusenius - (15:50): hm, it is somewhat too long  \nabusenius - (15:51): but makes it explicit  \nCalebJamesDeLisl - (15:52): in most script it won't be used. In code I don't think it matters.  \nabusenius - (15:52): ok, I'm renaming  \nCalebJamesDeLisl - (15:53): When you commit I will start modifying stuff to use it.  \nabusenius - (15:55): just need to fix the comments to satisfy checkstyle  \nCalebJamesDeLisl - (15:55): Don't worry, nothing of mine compiles yet.  \nCalebJamesDeLisl - (15:56): XWikiX509Certificate validateText(final String text, final String signature)  \nCalebJamesDeLisl - (15:56): good?  \nCalebJamesDeLisl - (15:56): Is there a use case for a Signature object?  \nabusenius - (16:00): hm, I don't think you can do something woth the signature, it's just a big number  \nabusenius - (16:00): even java's Signature takes byte[]  \nabusenius - (16:00): btw, is it a base64 encoded signature?  \nCalebJamesDeLisl - (16:01): yup.  \nabusenius - (16:01): maybe you should use something like base64data for the names of parameters that are encoded  \nabusenius - (16:02): because e.g. the text is not encoded  \nCalebJamesDeLisl - (16:02): good point.  \nCalebJamesDeLisl - (16:02): XWikiX509CertAndPrivateKey newCertAndPrivateKey();  \nCalebJamesDeLisl - (16:02): Look good?  \nCalebJamesDeLisl - (16:02): XWikiX509CertAndPrivateKey newCertAndPrivateKey(final int daysOfValidity);  \nCalebJamesDeLisl - (16:02): fixed...  \nabusenius - (16:04): yep  \nCalebJamesDeLisl - (16:12): committed, you can get a look at the altered interface. it's nice and clean. I think for the velocity version it will need to have deserialization util functions.  \nCalebJamesDeLisl - (16:12): private key \\_might\\_ not be enough to decrypt text, I have to look in to it.  \nabusenius - (16:17): committed xwikicertificate  \nabusenius - (16:17): looking at your code..  \nCalebJamesDeLisl - (16:21): Oh I forgot to mention, IMO xwiki-crypto should be a separate module from xwiki-rendering-macro-signed  \nCalebJamesDeLisl - (16:21): So feel free to hack away at xwiki-crypto, it won'd build now so you can only improve it ;)  \nsburjan` left at 16:23 (Quit: Peace and Protection 4.22  \nabusenius - (16:23): yes, that was my intention :)  \nabusenius - (16:24): why XWikiX509CertAndPrivateKey? I'd prefer something like XWikiX509KeyPair  \nabusenius - (16:25): oh, and signText needs a certificate too, because pkcs7 includes it  \nCalebJamesDeLisl - (16:26): Because java.security.KeyPair is a PublicKey and a PrivateKey and no cert.  \nabusenius - (16:26): what was your concirn against it?  \nabusenius - (16:26): well, it behaves in the same way :)  \nabusenius - (16:26): certificate is a signed public key  \nabusenius - (16:26): with a bit of extra  \nCalebJamesDeLisl - (16:27): so something like: String signText(final String textToSign, final XWikiX509CertAndPrivateKey toSignWith)  \nabusenius - (16:27): yes  \nCalebJamesDeLisl - (16:28): I agree XWikiX509CertAndPrivateKey is verbose but I am hesitant to go with the word KeyPair.  \nabusenius - (16:30): why not, it stores a pair of keys  \nabusenius - (16:30): (ok one of them is wrappen into a cert, by well)  \nabusenius - (16:30): \\*wrapped  \nCalebJamesDeLisl - (16:32): because KeyPair is so easily confused with java.security.KeyPair which stores something different.  \nCalebJamesDeLisl - (16:32): If you want XWikiX509KeyPair then I am fine with it.  \nabusenius - (16:33): I'd extend KeyPair if it wouldn't be final  \nabusenius - (16:33): ok  \nCalebJamesDeLisl - (16:34): java.everything = final is aggrivating. Sometimes I want to make the classloader disable that on load.  \nCalebJamesDeLisl - (16:36): I'm assuming that decrypt also requires the cert.  \nCalebJamesDeLisl - (16:37): One change: String encryptText(final String textToEncrypt, final X509Certificate[] certificatesToEncryptFor)  \nCalebJamesDeLisl - (16:38): IMO we should not demand XWikiX509, only return it.  \nabusenius - (16:38): just committed correct class names (sorry it will conflict)  \nsilviar1 left at 16:38 (Quit: Leaving.  \nCalebJamesDeLisl - (16:39): svn uppping  \nabusenius - (16:39): hm, in principle, since xwikicert extends x509 this should be fine  \nCalebJamesDeLisl - (16:40): don't like \"the certificate and matching private key to sign the text with.\"?  \nabusenius - (16:41): its ok  \nCalebJamesDeLisl - (16:41): It really is not a key pair, overuse of that term will lead people familiar with java.security.KeyPair to misunderstand.  \nabusenius - (16:43): but it behaves like a key pair  \nCalebJamesDeLisl - (16:44): What's the idea of the /data/ folder? If it has internal classes then it needs to be /data/internal/  \nabusenius - (16:45): all classes that are not components, but are just used to pass data around are there  \nabusenius - (16:45): like xwiki cert  \nabusenius - (16:45): I don't insist on having it  \nCalebJamesDeLisl - (16:46): oops nevermind, I missed the fact that you do have data/internal/  \nCalebJamesDeLisl - (16:47): XWikiX509Certificate is not an interface so it should go in /data/internal/ \u00a0\u00a0\u00a0nonpoint though since I just robbed it and am holding it hostage over in xwiki-crypto  \nabusenius - (16:48): it should be in xwiki-cypto anyway  \nCalebJamesDeLisl - (16:48): Hmm, does it need to know about KeyManager?  \nabusenius - (16:48): where exactly is not that important, but I wouldn't put it into internal/ because it is used in interfaces  \nabusenius - (16:49): the only method where it is used is verify()  \nabusenius - (16:49): to get the parent certificate from the key manager  \nCalebJamesDeLisl - (16:49): Overriding verify is dangerous anyway since we don't know where that might get called.  \nabusenius - (16:49): it is another verify  \nabusenius - (16:50): with vs. without parameters  \nCalebJamesDeLisl - (16:51): Ok. I am still worried about crypto expanding. Having it linked with more code makes me want to keep it away from the keymaker so that crypto is auditable.  \nCalebJamesDeLisl - (16:52): You were saying earlier that it was fingerprints, fromPEMString and toPEMString.  \nabusenius - (16:53): im principle the script signer could verify the certificates too  \nabusenius - (16:54): it is a convenience method, to check if the certificate is valid when you just have it  \nCalebJamesDeLisl - (16:54): The script signer can have a utility class do whatever verification it needs. The most important thing to crypto as few dependencies as possible.  \nabusenius - (16:55): I guess since the certificate will be used also for other things, it should not depend on anything special just for signed scripts  \nCalebJamesDeLisl - (16:55): So can you use a util class to deal with the cert manager?  \nabusenius - (16:55): ok, I'm fixing pkcs7 script signer to do that directly  \nabusenius - (16:56): have you moved xwiki cert somewhere else?  \nabusenius - (16:56): otherwise I'll remove verify() and key manger in it  \nCalebJamesDeLisl - (16:57): I put xwikiX509 in xwiki-crypto///internal  \nCalebJamesDeLisl - (16:58): any reason why you used org.apache.commons.codec.binary.Base64 \u00a0over org.bouncycastle.util.encoders.Base64?  \nabusenius - (16:59): I found commons base64 before bouncy castle base64 :)  \nCalebJamesDeLisl - (17:00): k  \njvelo joined #xwiki at 17:01  \nEnygma` left at 17:02 (Quit: Leaving.  \nCalebJamesDeLisl - (17:03): issuerFingerprint is not readily available.  \nCalebJamesDeLisl - (17:05): Of course your implementation can simply extend XWikiX509 again.  \nabusenius - (17:06): it is very difficult to find out issuer fingerprint if you don't know it allready  \nabusenius - (17:07): I was trying to avoid passing certificate chains around  \nCalebJamesDeLisl - (17:08): The only way it works is if you can construct with XWikiX509Certificate(X509Certificate cert)  \nabusenius - (17:08): if the cert is self-signed its ok  \nabusenius - (17:08): (pass null as issuer fingerprint)  \nabusenius - (17:09): otherwise I need to know somehow who signed it  \nabusenius - (17:09): or ignore the signer completely, then it is the same as self-signed  \nCalebJamesDeLisl - (17:09): Well, I got to hit the hay. Later on I'll throw out everything except get fingerprint from current cert, get name, import and export.  \nCalebJamesDeLisl - (17:10): You can extend it on your end and add whatever other functionality you like. Maybe I should make all of the wrapper functions final? ;)  \nabusenius - (17:11): I don't like the idea of wrapping it yet another time  \nCalebJamesDeLisl - (17:12): It's not another wrapper, it's just an extension.  \nCalebJamesDeLisl - (17:12): anyway, good night.  \nabusenius - (17:12): it doesn't work like that, all the crypto methods expect the superclass  \nabusenius - (17:13): ok, I'll think about it, good night  \nlucaa joined #xwiki at 17:16  \njvelo left at 17:28 (Ping timeout: 264 seconds  \nKermitTheFragger joined #xwiki at 17:34  \nasrfel left at 17:40 (Quit: Leaving.  \nsburjan left at 17:45 (Quit: Ex-Chat  \nevalica left #xwiki at 17:57  \nsdumitriu joined #xwiki at 18:12  \nlucaa left at 18:42 (Ping timeout: 265 seconds  \nabusenius left at 18:43 (Ping timeout: 240 seconds  \nKermitTheFragger left at 19:33 (Quit: Leaving  \nmflorea left at 19:37 (Quit: Leaving.  \narkub left at 19:41 (Quit: Leaving  \nabusenius joined #xwiki at 19:44  \nlucaa joined #xwiki at 20:07  \njvelo joined #xwiki at 20:11  \nlucaa left at 20:17 (Ping timeout: 240 seconds  \nlucaa joined #xwiki at 20:55  \nmflorea joined #xwiki at 21:18  \nlpereira joined #xwiki at 21:52  \nlpereira left at 22:20 (Quit: Leaving.  \nSvenDowideit left at 22:36 (Ping timeout: 240 seconds  \nnickless joined #xwiki at 22:40  \nabusenius left at 22:40 (Ping timeout: 252 seconds  \nSvenDowideit joined #xwiki at 22:43  \ntmortagne joined #xwiki at 22:44  \ntmortagne left at 22:44 (Client Quit  \nnickless left at 23:01 (Quit: Konversation terminated!  \n\n"}