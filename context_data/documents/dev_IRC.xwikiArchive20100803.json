{"id": "dev:IRC.xwikiArchive20100803", "url": "https://dev.xwiki.org/xwiki/bin/view/IRC/xwikiArchive20100803", "title": "IRC Archive for channel #xwiki - XWiki", "collection": "Eval-Large", "mimetype": "text/markdown", "language": "en", "content": "\nvmassol joined #xwiki at 00:01  \nsdumitriu left at 00:13 (Ping timeout: 260 seconds  \nvmassol left at 00:21 (Quit: Leaving.  \nflorinciu left at 00:36 (Quit: Leaving.  \nabusenius left at 00:58 (Ping timeout: 240 seconds  \ntsziklay left at 03:03 (Quit: ChatZilla 0.9.86 [Firefox 3.6.8/20100722155716]  \nmflorea joined #xwiki at 07:59  \nnpm left at 08:01 (Read error: Connection reset by peer  \nnpm joined #xwiki at 08:01  \nvmassol joined #xwiki at 08:43  \nflorinciu joined #xwiki at 08:51  \nsdumitriu joined #xwiki at 09:09  \nsdumitriu - (09:09): Hi vmassol  \nasrfel joined #xwiki at 09:10  \ntmortagne joined #xwiki at 09:13  \ntmortagne left at 09:21 (Quit: Leaving.  \ntmortagne joined #xwiki at 09:23  \nkibahop joined #xwiki at 09:24  \nkibahop left #xwiki at 09:24  \nsdumitriu left at 09:34 (Quit: Leaving.  \nKermitTheFragger joined #xwiki at 09:49  \njvdrean joined #xwiki at 09:51  \ntmortagne left at 09:52 (Read error: Connection reset by peer  \ntmortagne joined #xwiki at 09:52  \ntmortagne left at 09:52 (Client Quit  \ntmortagne joined #xwiki at 09:54  \nsburjan joined #xwiki at 09:55  \nabusenius joined #xwiki at 10:18  \nvmassol left at 11:20 (Quit: Leaving.  \nsdumitriu joined #xwiki at 11:30  \nmflorea - (11:35): guys, do you know why predefined queries ( http://svn.xwiki.org/svnroot/xwiki/platform/core/trunk/xwiki-core/src/main/resources/queries.hbm.xml ) don't include an order by clause? Right now the list of space names (getSpaces) and the list of page names from a given space (getSpaceDocsName) are not ordered. This affects the REST resources which use this queries, and this the Main.AllDocs tree shows pages in \"random\" order. I can customize this query easily on   \nmflorea - (11:39): sdumitriu: wdyt?  \nsdumitriu - (11:40): +1  \ntmortagne - (11:55): mflorea: +0  \nvmassol joined #xwiki at 11:56  \nsdumitriu - (11:56): Hi vmassol  \nvmassol - (11:56): hi sdumitriu  \nsdumitriu - (11:58): I have a questio  \nsdumitriu - (11:58): n  \nsdumitriu - (12:00): During EasyXWiki, it was suggested that all documents in a space should implicitly have the space's WebHome as a parent, if no parent was set, and each space should have as parent Main.WebHome  \nasrfel left at 12:02 (Ping timeout: 276 seconds  \nvmassol - (12:02): yes that's what I understood too  \nsdumitriu - (12:02): After many attempts, I got to implement it in XWikiDocument#getParentReference  \nvmassol - (12:03): shouldn't it be implemeted only at the display level?  \nvmassol - (12:03): IMO if a doc has no parent set it shouldn't have any set....  \nvmassol - (12:04): so the model shouldn't be modified IMO  \nmflorea left at 12:04 (Quit: Leaving.  \nsdumitriu - (12:04): getParentReference turns the relative reference into an absolute reference  \nvmassol - (12:04): it should return null I guess if no parent is set  \nsdumitriu - (12:05): The implementation is like:  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (this.parentReferenceCache == null) {  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String defaultDocument = this.configuration.getDefaultReferenceValue(EntityType.DOCUMENT);  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String defaultSpace = this.configuration.getDefaultReferenceValue(EntityType.SPACE);  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (getRelativeParentReference() != null) {  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.parentReferenceCache = this.explicitReferenceDocumentReferenceResolver.resolve(  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0getRelativeParentReference(), getDocumentReference());  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (!defaultDocument.equals(this.documentReference.getName())) {  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.parentReferenceCache = new DocumentReference(defaultDocument,  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(SpaceReference) this.documentReference.extractReference(EntityType.SPACE));  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (!defaultSpace.equals(this.documentReference.getLastSpaceReference().getName())) {  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.parentReferenceCache = new DocumentReference(defaultDocument, new SpaceReference(defaultSpace,  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(WikiReference) this.documentReference.extractReference(EntityType.WIKI)));  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}  \nsdumitriu - (12:05): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}  \nsdumitriu - (12:06): Well, the problem with an UI-only approach is that I can't always get a correct reference  \nsdumitriu - (12:07): For example:  \nsdumitriu - (12:07): - I'm in Space1.Doc1  \nsdumitriu - (12:07): - parent is Doc2 (resolved as Space1.Doc2)  \nsdumitriu - (12:07): - parent is Space2.Doc3  \nsdumitriu - (12:07): - parent is Doc4 (wrongly resolved as Space1.Doc4 instead of Space2.Doc4)  \nsdumitriu - (12:08): Fixing this bug in Velocity is going to be hard  \nvmassol - (12:08): I guess you need to talk to thomasM but IMO it should be a UI-only thing  \nsdumitriu - (12:08): And I don't quite agree with an UI-only implementation  \ntmortagne - (12:08): i agree with Vincent on that, it definitely has nothing to do with the model IMO  \nsdumitriu - (12:08): The UI just displays data, it shouldn't fake it  \nsdumitriu - (12:09): If the UI displays non-existing parents, then the UI is misleading  \nsdumitriu - (12:09): Either the space home is an implicit parent, and it is like that at all levels, or it isn't at all  \ntmortagne - (12:12): (lunch time for me)  \ncjdelisle - (12:14): abusenius: Looks like we're working on the same stuff, I just steamrolled r30565 because I had done the same thing + added another test.  \ncjdelisle - (12:14): so svn up  \nabusenius - (12:14): ok  \nabusenius - (12:15): I've just fixed broken stuff  \nabusenius - (12:15): tests in signed-scripts are still broken  \nabusenius - (12:17): btw, cjdelisle, I think XWikiX509KeyPair.getCertificate() should not throw any exceptions  \nabusenius - (12:17): it should not be possible to create an invalid key pair  \ncjdelisle - (12:18): So if it blows up then it's a RuntimeException?  \nabusenius - (12:18): maybe, but it should check that the certificate is correct right after deserialization  \nabusenius - (12:19): and not half an hour later in another code  \ncjdelisle - (12:19): I was just looking at a problem where you can create a cert with an invalid URI, deserialization? not so much.  \nabusenius - (12:19): well, you try to deserialize stuff in getCertificate()  \nabusenius - (12:20): you cannot stop creating certs with invalid URL anyway  \ncjdelisle - (12:20): that's fine as long as you do deserialization with the provided function, if you use SerializationUtils or ObjectInputStream, then that won't be called.  \nabusenius - (12:20): the only thing we can do is check that its signature is valid  \ncjdelisle - (12:21): It would be great if X509Certificate implemented Serializable but it doesn't so i make a byte[] and serialize (and deserialize) that.  \nabusenius - (12:22): I know, but it is better to use the provided method that checks all we need, and throw a runtime error  \nabusenius - (12:22): on errors  \nabusenius - (12:22): why have you made key pair serializable at all?  \ncjdelisle - (12:22): How else would you store it?  \nabusenius - (12:22): it seems that you have more workarounds than use just because of that :)  \nabusenius - (12:23): well, you have a canonical way to encode both certificate and private key  \nabusenius - (12:23): you just encrypt them afterwards and thats all  \ncjdelisle - (12:23): \"roll your own\" serialization?  \nabusenius - (12:23): yes, IMO in this case it is better  \ncjdelisle - (12:24): What happens if we create a better XWikiX509KeyPair later on?  \nabusenius - (12:24): we would still have encode() and decode() in the interface  \ncjdelisle - (12:25): So you have a serialized byte[] and no idea which version it is, what then?  \nEnygma` joined #xwiki at 12:25  \nabusenius - (12:26): well, we have the header  \ncjdelisle - (12:27): You end up with: first 4 bytes are the magic, then next byte says what version, then 4 bytes for length of the cert, then you have a byte[] which is the DER encoded cert, then 4 bytes for length of the private key, then a byte[] for the private key, then the checksum.  \nabusenius - (12:27): I get your point  \nabusenius - (12:28): but I need to get some food, bbl  \nabusenius - (12:28): :)  \ncjdelisle - (12:28): I started down this road on the passwd code.  \ncjdelisle - (12:28): See ya.  \nmflorea joined #xwiki at 13:13  \nabusenius - (13:22): there is a big difference between passwd stuff and certificates  \nabusenius - (13:22): passwd is designed such that we will have different implementations that needs to be serialized  \ncjdelisle - (13:23): Well certs are still serialized with plain old DER/PEM.  \nabusenius - (13:23): but there are only a few standard types of certs and we do not invent our format  \nabusenius - (13:23): we just use whatever cert uses for serialization  \ncjdelisle - (13:23): It's the keyPair which uses the weird serialization.  \nabusenius - (13:24): i.e. certificate factory does deserialization for us  \nabusenius - (13:24): well, it has 2 standard things  \nabusenius - (13:24): but secret key also has getEncoded() or similar  \nabusenius - (13:24): it is just not encrypted  \ncjdelisle - (13:24): That is used as well.  \ncjdelisle - (13:25): It's because I can't trust X509Certificate or PrivateKey not to change tomorrow.  \ncjdelisle - (13:26): + they don't implement Serializable.  \nabusenius - (13:26): I agree that java serialization is safer for the future, but using the serialization utils for deserialization directly is bad IMO, the object should deserialize itself  \ncjdelisle - (13:27): Still CertificateFactory and KeyFactory must know in advance what type of certificate (hardcoded as X509) and what type of key (variable) they will be deserializing.  \nabusenius - (13:29): it is known by however deserializes them usually  \nabusenius - (13:29): because you just cant use any certificate type  \nabusenius - (13:30): s/however/whoever/  \ncjdelisle - (13:30): The cert type is indeed known, the key XWikiX509Certificate is not XWikiX509RSACertificate.  \ncjdelisle - (13:31): s/the key/the key is not know aka:/  \ncjdelisle - (13:33): So you would have something where the cert is PEM encoded and the private key is appended to that?  \nabusenius - (13:34): yes, also pem encoded  \ncjdelisle - (13:34): You mean base64?  \nabusenius - (13:34): yes, base64(der)  \ncjdelisle - (13:34): base64(passwd(der))  \nabusenius - (13:35): yes  \ncjdelisle - (13:35): What happens if the key is not rsa?  \nabusenius - (13:35): any key can be der encoded  \nabusenius - (13:35): they are used in the wild somehow  \ncjdelisle - (13:36): How do we know how to decode?  \ncjdelisle - (13:36): You need the name of the algorithm to get the correct KeyFactory.  \nabusenius - (13:38): yes, we would need to know the type of both cert and key before  \nabusenius - (13:39): do you have any example where it wouldn't be the case?  \ncjdelisle - (13:40): Well since \"X509\" is in the name of the class, I think we can assume the cert type is always X509.  \nabusenius - (13:41): well, yes  \nEnygma` left at 13:41 (Ping timeout: 265 seconds  \ncjdelisle - (13:41): I have seen implementations of PrivateKey which use ECC so I wouldn't want to rule out future expandability.  \ncjdelisle - (13:45): Right now we have PEM which is standards compliant, we have password encryption which is not standards compliant but it's expandable with backward compatibility.  \ncjdelisle - (13:45): If we add something like:  \ncjdelisle - (13:45): -----BEGIN CERTIFICATE-----  \ncjdelisle - (13:45): ....  \ncjdelisle - (13:45): -----END CERTIFICATE-----  \ncjdelisle - (13:46): -----BEGIN PASSWORD ENCRYPTED PRIVATE KEY-----  \ncjdelisle - (13:46): .....  \ncjdelisle - (13:46): -----END PASSWORD ENCRYPTED PRIVATE KEY-----  \ncjdelisle - (13:47): We get semi standards compatibility because the PEM is compatible.  \ncjdelisle - (13:47): What we need to make sure of is that a version number is stuck in there somewhere so we aren't painted into a corner.  \nEnygma` joined #xwiki at 13:48  \nabusenius - (13:53): I wonder if we can append it in something like ----BEGIN XWIKI DATA----- ... -----END XWIKI DATA-----  \nabusenius - (13:54): the beginning will still be compliant  \ncjdelisle - (13:54): \"----BEGIN XWIKI DATA-----\" \u00a0\u00a0vs. \u00a0\u00a0\u00a0\u00a0\"-----BEGIN PASSWORD ENCRYPTED PRIVATE KEY-----\" is not really what I'm concerned about.  \ncjdelisle - (13:54): you would need:  \ncjdelisle - (13:54): -----END XWIKI DATA-----  \ncjdelisle - (13:54): VERSION: 1  \ncjdelisle - (13:54): ALGORITHM: RSA  \ncjdelisle - (13:54): .....  \nabusenius - (13:54): I meant to add a 3rd section  \nabusenius - (13:55): after -----EDN PASSWORD ...------ ------BEGIN XWIKI APPENDIX--- ...  \ncjdelisle - (13:55): And just put the version and algorithm there?  \nabusenius - (13:55): yes  \nabusenius - (13:56): we would be able to read it, but the beginning would be almost standard  \ncjdelisle - (13:56): Well from \"-----BEGIN PASSWORD ENCRYPTED PRIVATE KEY-----\" on will not be standard.  \nabusenius - (13:56): except if we use passwd for encrypting the key  \ncjdelisle - (13:57): If you don't use passwd then it's out in the open.  \nabusenius - (13:57): might be a good idea for exporting  \ncjdelisle - (13:58): Surely you don't want the private keys to be an sql command away.  \nabusenius - (13:58): we shouldn't use it to store stuff in xwiki of course  \ncjdelisle - (13:59): I'm only worried about how to store stuff in the database. If people want to export their keys to non-xwiki stuff then we'll revisit pkcs12  \ncjdelisle - (13:59): or plaintext (it's about the same)  \nabusenius - (13:59): n the other hand, if we use something non-standard for encrypting the key, we could as well put the info there  \nabusenius - (14:00): (into \"----passwd protected key---- ...\")  \ncjdelisle - (14:01): so like:  \ncjdelisle - (14:01): ----passwd protected key----  \ncjdelisle - (14:01): Version: 1  \ncjdelisle - (14:01): Algorithm: RSA  \ncjdelisle - (14:01): .....  \ncjdelisle - (14:01): ?  \nabusenius - (14:02): yes  \ncjdelisle - (14:03): Alternatively: XWikiPrivateKey implements Serializable.  \ncjdelisle - (14:03): let java do the work.  \nabusenius - (14:06): deserializing is not nice, unless we make certificate serializable too  \ncjdelisle - (14:06): Why not?  \nasrfel joined #xwiki at 14:07  \nabusenius - (14:07): but even then, the only way to make sure deserialization was successfull is to check something manully afterwaards  \nabusenius - (14:07): well, if I have a cert/key object I want to be \\*sure\\* they are correct whenever I use them  \ncjdelisle - (14:08): Deserialization usually blows up good if something goes wrong.  \nabusenius - (14:08): well, if you let java serialize a byte[] how do you know there wasn'T anything changed there?  \ncjdelisle - (14:09): When you deserialize, java gets the correct class automatically.  \nabusenius - (14:09): I mean correctness of the data  \nabusenius - (14:09): not the class  \ncjdelisle - (14:10): Meaning that a bit wasn't flipped in the database or something?  \nabusenius - (14:10): for example  \nabusenius - (14:10): you can check it easily after deserialization  \nabusenius - (14:10): but not if you use serialization utils  \nabusenius - (14:10): (directly)  \ncjdelisle - (14:11): You really can't prove that the key is correct without having the password to access it.  \nabusenius - (14:12): there yes, but it is ridiculous IMO that getFingerprint() might \u00a0throw an exception  \nabusenius - (14:12): just because the deserilization fails  \ncjdelisle - (14:13): Well if deserialization fails you are not getting that fingerprint, the question is how early can we notify the user?  \nabusenius - (14:13): we can use runtime exception there, but it still might fail, and will not even be catched  \nabusenius - (14:14): during the actual deserialization  \nabusenius - (14:14): thats the origin of the error  \nabusenius - (14:15): it is like, you import a cert, it imports fine, and on the next day when you try to verify something it fails  \ncjdelisle - (14:15): So you would have the cert as a pem string. That's not too difficult, the private key is where the most worries are.  \nabusenius - (14:15): maybe we could use an integrity checksum?  \nabusenius - (14:16): sha256(encrypted stuff)  \ncjdelisle - (14:17): What is that preventing?  \nabusenius - (14:17): data corruption  \nabusenius - (14:17): not preventing, but will make it visible right away  \ncjdelisle - (14:18): Corruption in the database?  \nabusenius - (14:19): in dtabase it doesnt matter that much, but things like backup etc  \nabusenius - (14:19): it is quite unlikely though  \ncjdelisle - (14:20): Either way, I think it's (currently) protected because the entire DefaultXWikiX509KeyPair is serialized.  \nabusenius - (14:20): hm, maybe a runtime exception is enough, it will not be thrown in normal circumstances  \nabusenius - (14:21): I mean, if you change the base64 data so that it is invalid, we will get a runtime exception too  \ncjdelisle - (14:23): You can make the static fromBase64String call getCertificate() so it will be checked there.  \nabusenius - (14:23): yes  \ncjdelisle - (14:23): Beyond that, I think you're just trying to prevent use of the java serialization api.  \ncjdelisle - (14:23): (directly)  \nabusenius - (14:24): what is your opinion on making getCertificate() throw a runtime exception rather than checked exception?  \nabusenius - (14:24): fromBase64String() is also more convenient imo  \ncjdelisle - (14:25): It's ok I guess, the fromBase64... should catch it and throw a normal exception.  \nabusenius - (14:25): yes  \nabusenius - (14:25): ok, another thing, why don't use String instead of byte[] for passwordEncryptedPrivateKey in the key pair?  \ncjdelisle - (14:25): If the remaining goal is to prevent use of the java serialization framework, you could just append a ? to the byte[]  \nabusenius - (14:26): you will not need workaround with reencoding it  \nabusenius - (14:26): what is that sign? (I see some face there)  \ncjdelisle - (14:27): It's a unicode something or other which I used to represent the null byte (a smily face.)  \nabusenius - (14:27): ah ok  \ncjdelisle - (14:27): (0x00 is printed as a smile in US-ASCII if I recall.)  \ncjdelisle - (14:28): ah no, it's 0x02  \ncjdelisle - (14:30): Anyway, I don't like the idea of appending identifiable garbage.  \ncjdelisle - (14:33): re: don't use String instead of byte[] for passwordEncryptedPrivateKey in the key pair?  \ncjdelisle - (14:33): Performance, I expect the key pair to be generated once and decoded many times.  \ncjdelisle - (14:34): If each time it has to convert the String to a byte[] then it will hurt performance.  \ncjdelisle - (14:34): Also it will make the final serialization size even larger.  \ncjdelisle - (14:35): Since java uses UTF-16 in a bid to occupy every register in every ram stick on earth.  \nabusenius - (14:36): ok, I guess it is better to write a method that encrypts byte[] to byte[]  \ncjdelisle - (14:36): I would agree but I'm not sure that it will be wanted at the script level.  \nflaviusolaru joined #xwiki at 14:40  \ncjdelisle - (14:40): I know need for byte[] encrypt(... \u00a0\u00a0will not exist for a while since the db can't handle byte[]  \ncjdelisle - (14:44): The fortunate news is we won't be painted into a corner, if in the future we want something like this, we just need to extend DefaultXWikiX509KeyPair with DefaultXWikiX509KeyPair2 and make whatever changes  \nflaviusolaru - (14:45): any gurus in maven, i want to create a POM file for a project that depends on curriki but i want to exclude some curriki documents from xar build  \nflaviusolaru - (14:45): how can i achieve this and where can i find information on the syntax i should use  \nabusenius - (14:46): well, having a method that handles byte[] in the crypro service will not hurt, the String method would use it too  \nabusenius - (14:47): crypto converts to byte[] internally anyway  \ncjdelisle - (14:48): Hmm, then you would have to extend PasswordCiphertext to have a PasswordCiphertext which returned byte[] instead of String.  \ncjdelisle - (14:48): Ha, can't do that.  \nabusenius - (14:49): no, I mean 2 methods  \nabusenius - (14:49): it doesn'T fit well into the current interface though  \ncjdelisle - (14:50): 2 decrypt methods?  \ncjdelisle - (14:52): It's the old problem of \"you have a ciphertext and you want to know if it should be a String or a byte[]\" :)  \ncjdelisle - (14:53): Maybe not much of a problem in this case though.  \nabusenius - (14:53): well, we would only use string - string and byte - byte  \ncjdelisle - (14:53): \"string and byte\"?  \nabusenius - (14:53): byte[]  \nabusenius - (14:54): (string <-> string) and (byte[] <-> byte[]) :)  \ncjdelisle - (14:55): Ok, so 2 new methods, one encrypt and one decrypt.  \nabusenius - (14:56): ah, yes  \ncjdelisle - (14:57): byte[] encryptBytes(final byte[] toEncrypt, final String password)  \ncjdelisle - (14:58): byte[] decryptBytes(final byte[] encryptedBytes, final String password)  \ncjdelisle - (14:58): ?  \ncjdelisle - (15:07): flaviusolaru: A quick look at the xar mojo shows that it seems to accept excludes, you can do some googling about maven <excludes> and I think you can put a set of excluded files in the <configuration.>  \ncjdelisle - (15:09): abusenius: I'm sold on adding the \\*cryptBytes methods, can I talk you into writing them :) ?  \nabusenius - (15:09): I can write them, it is not much more than copy-paste from string methods I guess  \ncjdelisle - (15:11): And then direct the string methods to the byte methods.  \nztane - (15:14): hi, is there any way to disable the rendering of bare urls to links?  \nztane - (15:15): we are still having problems with  \ntmortagne - (15:16): ztane: you can escape them using http:~//someurl for example or {{{http://someurl}}} url use the WYSIWYG which will take care of properly escape it  \nztane - (15:17): tmortagne: yes, but i need the exact opposite...  \ntmortagne - (15:17): s/url use the WYSIWYG/or use the WYSIWYG/  \ntmortagne - (15:17): ztane: i don't understand what you mean by \"disable the rendering\" then  \ntmortagne - (15:17): can you give an more detailed example of your use case  \nztane - (15:17): hmm ...  \nztane - (15:18): ok...  \nztane - (15:20): we have a problem due to some bug in xwiki, which makes it embed complete urls for interwiki links in for example user profile page, etc.  \nztane - (15:20): and ...  \nztane - (15:20): these in turn are rendered to html links by the xwiki rendering engine... because it thinks they are in the middle of some wikitext,  \nztane - (15:20): when they actually are inside a href=\"...\"  \nztane - (15:21): since we do not need such functionality at all, it would be easy to overcome this bug by disabling that...  \nztane - (15:23): the other possibility would be to fix all these broken pages by hand (and there are many), or fix the bug somewhere.  \ntmortagne - (15:26): ztane: the issue is that disabling simple URL parsing is really nor easy since it's hardcoded in the parser  \ntmortagne - (15:27): s/nor/not/  \nztane - (15:27): hmm  \nztane - (15:27): then.. i wonder what can be at fault...  \ntmortagne - (15:28): do you really need wiki syntax in your html content ?  \nztane - (15:28): NO!  \ntmortagne - (15:28): then why did you enable wiki syntax ?  \ntmortagne - (15:28): the default is disabled  \nztane - (15:28): I did not  \ntmortagne - (15:28): {{html}} does not interpret wiki syntax  \ntmortagne - (15:28): {{html wiki=true}} does  \nztane - (15:28): yes  \ntmortagne - (15:29): so if you are using {{html}} there is no why the wiki syntax is interpreted  \nztane - (15:29): a sec...  \ntmortagne - (15:29): s/why/way/  \nztane - (15:30): ok  \nztane - (15:30): XWiki.XWikiUserSheet has... {{html wiki=true}} around most of its content  \nztane - (15:30): as an example...  \nztane - (15:31): inside that, $doc.getURL('inline', 'category=profile') returns for me for some reason  \ntmortagne - (15:31): ztane: that's because XWikiUserSheet need wiki syntax  \nztane - (15:31): the full server url, http://server.name.com/xwiki/...  \nztane - (15:31): and that then gets rendered by the simple link parser to a html link WITHIN another html link.  \nztane - (15:32): as a result half of the pages do not work unless they are fixed by hand  \ntmortagne - (15:33): ztane: you can put your $doc.getURL('inline', 'category=profile') code inside a sub {{html}} macro or inside verbatim block like in {{{$doc.getURL('inline', 'category=profile')}}}  \nztane - (15:33): yes  \nztane - (15:33): but that is xwiki page  \nztane - (15:33): all of them are broken  \nztane - (15:34): so obviously i should not have to fix all pages by hand on a fresh installation  \ntmortagne - (15:35): ztane: if it's standard wiki then you can create a jira issue in http://jira.xwiki.org so that we can fix it  \nztane - (15:35): yeah  \nztane - (15:36): if only i would know where the bug is  \ntmortagne - (15:36): just describe how to reproduce it, we'll find ;)  \nztane - (15:36): as i said :P  \nztane - (15:37): steps to reproduce: install 2.3.2 on apache + tomcat 5.5, go to user profile :P  \nztane - (15:37): last time i asked a dev said \"cannot reproduce\" :S  \ntmortagne - (15:37): you probably have some special configuration to get absolute URLs  \nztane - (15:38): indeed :S  \ntmortagne - (15:38): that itself looks like a bug already  \nztane - (15:38): so should they be relative then?  \ntmortagne - (15:38): do you have xwiki.virtual=1 in xwiki.cfg ?  \nztane - (15:38): if so...  \nztane - (15:38): nope  \ntmortagne - (15:38): by default yes they should be relative  \ntmortagne - (15:39): all generated local URL are relative by default  \nztane - (15:39): hmm :))  \nztane - (15:39): that explains it  \ntmortagne - (15:40): yep that's why you got a \"cannot reproduce\" i guess  \ntmortagne - (15:41): do you access the wiki through a apache httpd ?  \nztane - (15:41): yes  \nztane - (15:41): have to :S  \ntmortagne - (15:41): are you able to try accessing directly tomcat  \ntmortagne - (15:41): to see if you have the same issue  \ntmortagne - (15:42): if not that's probably a httpd configuration issue (the fact that you get absolute urls)  \nztane - (15:42): ok shall test it  \ntmortagne - (15:42): even if i'm not sure what configuration issue could do that  \nztane - (15:44): anyway, the links are correct and so on, and would work, would they not be converted by {{html wiki=true}}  \ntmortagne - (15:44): sure but thiis code does not expect absolute URLs which is why there is no protection in it  \nztane - (15:46): ah you're correct,  \nztane - (15:46): works when used directly :S  \ntmortagne - (15:47): you should probably create a jira issue anyway about your use case so that we take care or protecting better this code even when there is a configuration issue like this you have somewhere  \ntmortagne - (15:48): i.e. it should be bullet proof as much as possible ;)  \nztane - (15:49): will do  \ntmortagne - (15:50): thanks  \nabusenius - (15:53): cjdelisle: PasswordCiphertext is also fixated on using String  \nabusenius - (15:53): although the first thig it does is converting to byte[]  \nabusenius - (15:53): \\*thing  \nabusenius - (15:53): wdyt about using byte[] only there?  \ncjdelisle - (15:54): I suppose.  \nabusenius - (15:55): i.e. init(byte[], Whatever ...) instead of init(String, Whatever ...)  \ncjdelisle - (15:56): ok.  \ncjdelisle - (15:56): CipherTEXT though?  \nabusenius - (15:57): hm, it is usually called like this  \nabusenius - (15:57): CipherData sounds bad  \ncjdelisle - (15:58): Your call.  \nvmassol left at 15:58 (Read error: Connection reset by peer  \nvmassol joined #xwiki at 15:58  \ncjdelisle left #xwiki at 16:44  \ncjdelisle joined #xwiki at 16:44  \ncjdelisle left #xwiki at 16:46  \ncjdelisle joined #xwiki at 16:58  \nsburjan left at 17:17 (Quit: Ex-Chat  \nztane - (17:18): tmortagne: proxypreservehost on  \ntmortagne - (17:22): ztane: here is a snippet of the configuration we usually use in a virtual host: http://pastebin.com/rQQBh0Nx we always get proper relative URL with that for local links  \ntmortagne - (17:22): we use proxy\\_ajp module  \nztane - (17:25): I think it did not work alone, needed the proxypreservehost  \nztane - (17:25): thanks anyway  \ntmortagne - (17:27): ztane: np  \nevalica joined #xwiki at 17:32  \nevalica left at 17:33 (Client Quit  \njvdrean - (17:34): Hi, does anyone remember having issue with clirr when adding a new component in the core ?  \njvdrean - (17:35): clirr complaining that it's not able to retrieve the last stable version of the new module (which is quite normal)  \nabusenius - (17:36): yes, me :)  \nabusenius - (17:36): <properties><xwiki.clirr.skip>true</xwiki.clirr.skip></properties>  \nabusenius - (17:37): cjdelisle: are you changing something? I'm about to commit  \ncjdelisle - (17:37): nope, trying to figure out irc client certs :)  \nabusenius - (17:42): ok, commiting  \njvdrean - (17:51): abusenius: thanks  \ncjdelisle - (17:51): ahh so you managed to avoid breaking compatibility for the passwd encryption.  \nabusenius - (17:52): only keypair regression test broke  \nabusenius - (17:52): but because the old version was broken :)  \ncjdelisle - (17:53): that looks much nicer :)  \nasrfel left at 17:54 (Quit: Leaving.  \ncjdelisle - (17:56): 5 lines of base64 shorter.  \ncjdelisle - (17:56): 550 chars.  \nabusenius - (18:00): yea, secret key was base64 encoded  \nabusenius - (18:01): I need to fix signedscripts, the tests are completely broken after all these changes...  \ncjdelisle - (18:03): Hmm, I think that's it for crypto. I can't think of anything else which is needed.  \nabusenius - (18:05): methods for storing/loading certificates and keys as properties?  \nabusenius - (18:05): we have discussed it some time ago  \nabusenius - (18:06): and I still need proposed API for doing that  \nabusenius - (18:08): http://lists.xwiki.org/pipermail/devs/2010-July/019503.html  \ncjdelisle - (18:08): IMO the serialization which you just worked on is the front facing part of that. Everything else should be external (to crypto).  \nabusenius - (18:09): where would it go to?  \ncjdelisle - (18:10): Not sure but it seems to me that crypto should be completely stateless.  \nabusenius - (18:11): in principle the whole UserDocumentUtils doesn'T really fit into crypto  \ncjdelisle - (18:12): I very much agree, but it is much safer to get some kind of assurence of who the requesting user is.  \nabusenius - (18:13): well, we also have get known fingerprints there etc.  \ncjdelisle - (18:13): define \"known\"  \nabusenius - (18:14): so, either we move all cert/key code elsewhere (2 methods will be left there) or move all of it inside  \nabusenius - (18:14): I mean getCertificateFingerprintsForUser()  \ncjdelisle - (18:16): Why do you need all fingerprints for a given user?  \nboscop joined #xwiki at 18:17  \nabusenius - (18:18): to list the stored certificates  \nabusenius - (18:18): find out how many they are  \ncjdelisle - (18:18): Is this for signing or for verifying?  \nabusenius - (18:18): verifying  \nboscop - (18:18): hi. how does the bridge the the jabber MUC work?  \ncjdelisle - (18:18): nope  \ncjdelisle - (18:18): oh how :)  \nboscop - (18:19): yeah ;)  \nboscop - (18:19): is it publicly available somehow?  \ncjdelisle - (18:19): the code?  \nboscop - (18:20): or SAAS maybe, whatever works  \ncjdelisle - (18:20): It's a perl script, I have a copy kicking around somewhere here.....  \ncjdelisle - (18:23): http://outflux.net/software/pkgs/jirc-bridge/  \nboscop - (18:23): ah nice :)  \nboscop - (18:23): and why doesn't it work, if I may ask? :)  \njvdrean left at 18:24 (Quit: Leaving.  \ncjdelisle - (18:24): Oh it works fine, it got neglected back when the ejabberd server started crashing constantly and nobody has put it back up since.  \nboscop - (18:25): I see  \ncjdelisle - (18:26): So verifying ( abusenius ) works how? You get the cert and know it signed the text, then what?  \nabusenius left at 18:27 (Ping timeout: 240 seconds  \ncjdelisle - (18:29): I think we should remove \"Testing a new public Jabber chat: [[email\u00a0protected]](https://dev.xwiki.org/cdn-cgi/l/email-protection)\" from the topic.  \nflaviusolaru left at 18:29 (Read error: Connection reset by peer  \nmflorea left at 18:35 (Quit: Leaving.  \nabusenius joined #xwiki at 18:37  \ntsziklay joined #xwiki at 18:38  \ncjdelisle - (18:39): We were talking about the signature verification process...  \nabusenius - (18:45): let me grab a tea, brb  \nabusenius - (18:48): so  \nabusenius - (18:48): a signed macro parses the content, it contains among others the signature, content, user name and certificate fingerprint  \ncjdelisle - (18:49): hmm, that's redundant since the fingerprint is in the signature.  \nabusenius - (18:50): not really, it is just the signature, nothing else  \ncjdelisle - (18:50): ?  \nabusenius - (18:50): then it checks if the certificate with this fingerprint is known and belongs to the user  \nabusenius - (18:51): well, it is \\*the\\* signature :)  \ncjdelisle - (18:51): \"signed macro parses the content, it contains among others the signature, content, user name and certificate fingerprint\"  \ncjdelisle - (18:52): Except for the content, these are all parts of the signature.  \nabusenius - (18:52): I don'T distinguish between signature and the rest  \nabusenius - (18:52): when I say signature, I mean the data that I get from Signature class sign()  \ncjdelisle - (18:53): Ok, so what happens is you read the signature, get the cert, read the cert, get the fingerprint and user name?  \nabusenius - (18:54): example: http://pastebin.com/vtrEbsMi  \nKermitTheFragger left at 18:54 (Quit: Leaving  \nabusenius - (18:54): I verify the content  \ncjdelisle - (18:54): Author \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: UID=XWiki.Admin \u00a0<-- contained in the signature  \nabusenius - (18:55): no  \nabusenius - (18:55): it is a detached signature  \ncjdelisle - (18:55): Detached?  \nabusenius - (18:55): it does not contain anything other that a big random number  \nabusenius - (18:55): ok, a hash of the text  \nabusenius - (18:56): and some random number  \ncjdelisle - (18:56): verifyText returns a certificate.  \nabusenius - (18:56): it is the PKCS+7 detached  \nabusenius - (18:56): right, the cert is there  \nabusenius - (18:56): but it wasn't always like that :)  \ncjdelisle - (18:57): when was that?  \nabusenius - (18:57): and beside this, I wanted the name to be human readable  \ncjdelisle - (18:57): Is that name signed over?  \nabusenius - (18:57): at the very beginning, when I wrote the parser  \nabusenius - (18:57): yes  \ncjdelisle - (18:57): but the signature is not.  \nabusenius - (18:58): yes, everything other than signature  \ncjdelisle - (18:59): so the signature algorithm replaces everything between \"Signature: \" and \"------\" with \"\"  \ncjdelisle - (18:59): ?  \ncjdelisle - (18:59): (empty string)  \nabusenius - (19:00): no, it is not there yet when it is signed  \nabusenius - (19:00): there is a method that puts everything except signature into a string  \ncjdelisle - (19:00): Well it is when it's verified, so it must be removed.  \nabusenius - (19:00): its output is used in sign and verify  \nabusenius - (19:00): well, yes  \nabusenius - (19:01): but not with regex  \nabusenius - (19:01): it is \"parsed\" with regex into a SignedScript object  \ncjdelisle - (19:02): Why not be like PGP and just say {{signed}} and everything is singed until {{signature}} then you have a signature then {{/signed}}  \nabusenius - (19:02): it was easier to do, everything is just a \"key : value\"  \ncjdelisle - (19:03): The problem for me is I have a hard time proving that there is no way to sneak arbitrary data into the \"signed area\"  \nabusenius - (19:04): making a nested {{signature}} macro is more complicated, I'd need xwiki 2.0 parser to extract that  \nabusenius - (19:04): but it should not execute the content yet  \nabusenius - (19:05): it is way easier and simpler to not treat signature specially  \ncjdelisle - (19:05): I don't think so, look at the {{code}} macro, you could put a {{signature}} inside of a {{code}} block and it won't be parsed.  \nabusenius - (19:06): well, then it would be {{signed}} stuff {{code}} code {{/code}} {{signature}} signature {{/signature}} {{/signed}}  \nabusenius - (19:06): why?  \nabusenius - (19:06): how is it better?  \nabusenius - (19:07): and \"proving\" that everything else other than signature is signed is easy  \nabusenius - (19:07): it is a for loop with if (key == \"signature\") continue;  \nabusenius - (19:08): the stuff after ----------- is the code  \ncjdelisle - (19:08): So you sign each key->value pair?  \nabusenius - (19:08): proving that xwiki 2.0 parser works is impossible  \nabusenius - (19:08): yes  \nabusenius - (19:09): I just put them as is to byte[] and sign  \ncjdelisle - (19:09): can you give me an idea of what the text looks like after mangling?  \nabusenius - (19:10): org.xwiki.signedscripts.internal.PKCS7SignedScript.getDataToSign()  \nabusenius - (19:10): imagine the example I gave you without pretty-printing and spaces  \nabusenius - (19:10): and without sugnature  \ncjdelisle - (19:11): so you remove all whitespace, and once you hit \"Signature \u00a0\u00a0\u00a0:\" you remove everything until -------?  \nabusenius - (19:12): no, I have all key-values in a Mp allready  \nabusenius - (19:12): Map  \nabusenius - (19:12): so I just don't put signature  \ncjdelisle - (19:12): So you're signing a map?  \nabusenius - (19:13): look at getDataToSign() :)  \ncjdelisle - (19:13): what's the point of this? XWikiVersion \u00a0: 2.4M2  \nabusenius - (19:13): well, it should be the current xwiki version  \nflorinciu left at 19:14 (Quit: Leaving.  \nabusenius - (19:14): to prevent possible version rollback  \ncjdelisle - (19:14): version rollback? Meaning you will break scripts when the version increments?  \nabusenius - (19:15): at some point we might discover a vulnerability and reject scripts signed with old vulnerable versions  \ncjdelisle - (19:15): Ok, so you just trust the user to set that value correctly when signing.  \nabusenius - (19:16): yes, it is not perfect of course  \ncjdelisle - (19:16): Well if it's not about suspecting the signer, then it is indeed perfect.  \ncjdelisle - (19:17): Pattern.compile(\"^([^#\\\\\\\\]\\*|[^#]\\*[^#\\\\\\\\])(#.\\*)?$\");  \nabusenius - (19:17): would help if the vulnerability does not leak the secret key  \ncjdelisle - (19:17): Nice to see you using regex to give the hackers a head start.  \nabusenius - (19:17): I have a todo to write a normal parser :)  \nabusenius - (19:18): it is not the most important thing right now  \ncjdelisle - (19:18): And then upgrading to javacc which autogenerates more code than anyone can review.  \nflorinciu joined #xwiki at 19:18  \ncjdelisle - (19:19): It's clear to me that this will never be able to be implemented in javascript.  \nabusenius - (19:19): assume that javacc works, then you can indeed review  \nabusenius - (19:20): no, there is an API that you can use to get the stuff you should sign  \nabusenius - (19:20): see ScriptSigner  \ncjdelisle - (19:21): So the browser must pass the code to your mangler and get it back in a form which the user can't read and understand and must sign on faith?  \nabusenius - (19:22): well, you need to find out all the data you should put there somehow  \nabusenius - (19:22): and I wouldn'T call it \"mangler\" it just puts the stuff into one big string  \ncjdelisle - (19:23): The script is already one big string, this just modifies it.  \nabusenius - (19:23): well, think about signing  \nabusenius - (19:23): you only have the code at that point  \ncjdelisle - (19:24): ?  \nabusenius - (19:24): the stuff below ------  \nabusenius - (19:24): you write it, it say you need PR  \nabusenius - (19:24): so you sign it  \ncjdelisle - (19:25): {{signature}}  \ncjdelisle - (19:25): .........  \ncjdelisle - (19:25): {{/signed}}  \nabusenius - (19:25): you should never ever need to write it by hand  \ncjdelisle - (19:26): A format like that leaves no room for tricks  \nabusenius - (19:26): especially because if you make a typo somewhere it will not be compatible to the rest  \nabusenius - (19:26): so you want the user too look up what fingerprint his certificate has?  \nabusenius - (19:27): and convert the time to UTC? :)  \ncjdelisle - (19:27): Of course you can't write it by hand unless you can do powers of 65537 in your head. You could have the most minimal script generate that form of signature.  \nabusenius - (19:28): ok, we could say that if you have {{signed}} with only the content, then display UI to sign  \nabusenius - (19:28): in any case, server-side is obvious, you just do the thing  \nabusenius - (19:29): how do you know user name, fingerprint etc. from java script?  \ncjdelisle - (19:29): user name is in the certificate.  \ncjdelisle - (19:29): certificate is in the browser (fingerprint)  \ncjdelisle - (19:30): I may be wrong but I seem to recall a timestamp gets thrown into pkcs7 signatures.  \nabusenius - (19:30): this format has more stuf in there  \nabusenius - (19:31): ExpiresOn for example  \ncjdelisle - (19:31): Certificates all have an expiration date.  \nabusenius - (19:31): expires for the code, not cert  \ncjdelisle - (19:32): Failed to lookup component [role = [org.xwiki.crypto.passwd.PasswordCryptoService]  \ncjdelisle - (19:32): Did I forget something?  \nabusenius - (19:32): it is broken since you started changing x509keypair  \nabusenius - (19:33): I have not figured out what's wrong yet  \nabusenius - (19:33): it fails during initialization of components for some reason  \ncjdelisle - (19:33): Just noticed you're awesome error message :)  \nabusenius - (19:33): I gave my best :)  \ncjdelisle - (19:34): Can't find descriptor for the component [role = [org.xwiki.configuration.ConfigurationSource] hint = [default]]  \nabusenius - (19:34): but why?  \ncjdelisle - (19:35): Maybe you need to declare a dependency?  \nabusenius - (19:37): copying dependencies from xwiki-crypto...  \ncjdelisle - (19:37): AbstractMockingComponentTestCase  \ncjdelisle - (19:37): that's it.  \ncjdelisle - (19:37): Not dependencies.  \nabusenius - (19:38): well, it mocks everything  \nabusenius - (19:39): and it used to work  \nabusenius - (19:40): btw, adding dependencies doesn'T help  \ncjdelisle - (19:41): That's because you can mock one dependency but it won't load the dependencies for that dependency.  \nabusenius - (19:42): I see  \nabusenius - (19:42): can it mock more than one?  \nabusenius - (19:42): i.e. I mock the dependencies first  \nvmassol left at 19:43 (Quit: Leaving.  \ncjdelisle - (19:44): What I did was to load everything from the component manager in the setUp()  \nabusenius - (19:46): trying to use several @MockingRequirements  \ncjdelisle - (19:51): I got to go to bed, when that's working I'll spend a little time attacking it but I'm pretty sure modifying the data before signing is the wrong approach. Take a look at xml signing, it seems they are almost constantly discovering total breaks.  \nabusenius - (19:52): what do you want to sign then? just the code?  \nabusenius - (19:52): good night  \nflorinciu left at 19:52 (Quit: Leaving.  \ncjdelisle - (19:54): yea, you want to sign exactly what the user writes, maybe tack on a piece of information at the end, but only if it cannot be extracted from the cert.  \nabusenius - (19:55): thats exactly what I'm doing (except that I duplicate some info)  \ncjdelisle - (19:57): You seem to be modifying some of the original data.  \nabusenius - (19:58): no, I dont  \ncjdelisle - (19:58): then what is the javacc parser all about?  \nabusenius - (19:58): I don't see the \"key : value\" pairs as the original data  \nabusenius - (19:59): only the key and value itself  \nabusenius - (19:59): not the spaces inbetween  \nabusenius - (19:59): they are there just to make it look nicer  \nabusenius - (19:59): the actual important data is the content  \ncjdelisle - (19:59): JSR-105 tried to make xml into something which could be signable and not break the signature even if the xml was rendered differently.  \nabusenius - (19:59): I don't touch it  \ncjdelisle - (19:59): http://neubia.com/archives/000363.html  \ncjdelisle - (20:00): http://www.usenix.org/publications/login/2008-02/pdfs/sood.pdf  \nabusenius - (20:01): I don't try to make it signable when rendered differently  \nEnygma` left at 20:01 (Ping timeout: 252 seconds  \nabusenius - (20:01): I can sign the pretty-printed version if you like, I don't care  \nabusenius - (20:01): parsing is about making it usable  \nabusenius - (20:01): turning a big string into something you can work with  \nabusenius - (20:02): i.e. smaller strings  \nabusenius - (20:02): I need to check expiration date for example  \nabusenius - (20:02): so I need to parse it  \ncjdelisle - (20:02): If you are going to sign anything it needs to be what the user sees.  \ncjdelisle - (20:03): ok bed time :)  \nabusenius - (20:04): good night :)  \nabusenius - (20:05): then I suggest a step in between, you show the user what the server wants it to sign, then he can sign it  \nEnygma` joined #xwiki at 20:06  \nEnygma` left at 20:53 (Ping timeout: 260 seconds  \nmflorea joined #xwiki at 20:56  \ntmortagne left at 22:15 (Ping timeout: 265 seconds  \nmflorea left at 23:16 (Quit: Leaving.  \n  \n{{/code}}\n"}