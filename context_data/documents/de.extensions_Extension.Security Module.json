{
  "id": "extensions:Extension.Security Module",
  "url": "https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module",
  "title": "Authorization API",
  "collection": "Eval_de",
  "mimetype": "text/markdown",
  "language": "de",
  "content": "Here is the translated text in German:\n\n---\n\n|  |  |\n| --- | --- |\n| cog | **Steuert Berechtigungen für alle Wiki-Elemente** |\n\n|  |  |\n| --- | --- |\n| Typ | JAR |\n| Kategorie |  |\n| Entwickelt von | [XWiki Development Team](https://xwiki.org/xwiki/bin/view/XWiki/XWikiTeam) |\n| Bewertung | \n\n* \n* [1](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module \"Schlecht\")\n* [2](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module \"Befriedigend\")\n* [3](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module \"Gut\")\n* [4](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module \"Sehr gut\")\n* [5](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module \"Ausgezeichnet\")\n\n0 Stimmen\n\n|\n| Lizenz | GNU Lesser General Public License 2.1 |\n\n|  |  |\n| --- | --- |\n| Gebündelt mit | XWiki Standard |\n\n**Installierbar mit dem Extension Manager**\n\n[Download v16.3.1](https://extensions.xwiki.org/xwiki/rest/repository/extensions/org.xwiki.platform%3Axwiki-platform-security-authorization-api/versions/16.3.1/file?rid=maven-xwiki)[Quellen](https://github.com/xwiki/xwiki-platform/tree/master/xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authorization/xwiki-platform-security-authorization-api/)[Probleme](https://jira.xwiki.org/browse/XWIKI)\n\nInhaltsverzeichnis\n\n* [Beschreibung](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HDescription)\n* [Security Authorization API](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HSecurityAuthorizationAPI)\n\t+ [Allgemeine API-Schnittstelle](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HGeneralAPIinterface)\n\t+ [Kontextuelle API-Schnittstelle (seit 6.1RC1)](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HContextualAPIinterface28since6.1RC129)\n\t+ [Aktuellen Autor ändern (seit 8.3RC1)](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HChangecurrentauthor28since8.3RC129)\n\t+ [Scripting-API (seit 6.1RC1)](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HScriptingAPI28since6.1RC129)\n\t+ [Verwendung von checkAccess() versus hasAccess()](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HcheckAccess2829versushasAccess2829usage)\n\t+ [Einige Definitionen, wie sie von diesem Modul gesehen werden](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HSomedefinitionsasseenbythismodule)\n\t+ [Rechte und Zugriffsentscheidungen](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HRightsandaccessdecisions)\n\t\t- [Recht-Definitionen](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HRightdefinitions)\n\t\t- [Vordefinierte Standardrechte](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HDefaultrightsbeingpredefined)\n\t\t- [Zusätzliche Richtlinien des Standard-Rechtsetzers](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HDefaultrightsettleradditionalpolicies)\n\t\t- [Einschränkungen](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HLimitations)\n\t+ [API und Brücke](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HAPIandbridge)\n\t\t- [Sicherheitsreferenzen](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HSecurityReferences)\n\t\t- [Öffentliche Brückenschnittstelle](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HPublicbridgeinterface)\n\t+ [Ereignisse](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HEvents)\n\t+ [Cache](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HCache)\n* [Security Authentication API](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HSecurityAuthenticationAPI)\n* [Security URL API](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HSecurityURLAPI)\n* [Voraussetzungen & Installationsanweisungen](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HPrerequisites26InstallationInstructions)\n* [Abhängigkeiten](https://extensions.xwiki.org/xwiki/bin/view/Extension/Security%20Module#HDependencies)\n# Beschreibung\n\nDieses Modul ist verantwortlich für die Benutzerauthentifizierung, Zugriffsautorisierung und kontextuelle Sicherheit. Aktueller Status:\n\n* Die Authorization API wird durch Bereitstellung einer Brücke zu den (alten) RightService APIs implementiert (siehe [$xwiki.hasAccessLevel()](https://xwiki.org/xwiki/bin/view/ScriptingDocumentation/?api=xwiki&xpage=embed)). Diese Brücke wird standardmäßig seit Version 5.0M2 verwendet. Dieses Modul ist seit Version 4.0M1 verfügbar, sollte jedoch erst seit der Version 5.0 als stabil betrachtet werden.\n* Die Authentication API ist noch nicht implementiert (der [alte Kerncode](http://www.github.com/xwiki/xwiki-platform/tree/master/xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/user/impl/xwiki) wird derzeit verwendet und [dokumentiert](https://xwiki.org/xwiki/bin/view/Documentation/AdminGuide/Authentication/)). Es wurden jedoch einige authentifizierungsbezogene APIs eingeführt (siehe unten).\n\n# Security Authorization API\n\nUm Effizienz zu gewährleisten, verwendet dieses Modul Caching-Techniken, um sowohl Zugriffsregeln als auch resultierende Zugriffsentscheidungen des Autorisierungs-Setzers zu speichern. Mehrfaches Überprüfen des Zugriffs auf dasselbe Objekt (oder Objekte derselben Hierarchie ohne speziellen Zugriff) für denselben Benutzer erfordert nur sehr schnelle Cache-Abfragen. Die überbrückte Version des alten com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl wird daher org.xwiki.security.authorization.internal.XWikiCachingRightService genannt. Es sollte nur verwendet werden, wenn die neue API nicht Ihren Anforderungen entspricht.\n\nDa der kontextuelle Aspekt des Moduls noch nicht verfügbar ist, bietet dieses Modul keine kontextuellen Antworten und liefert nur Zugriffsantworten basierend auf statischen (während einer Anfrage) Zugriffsregeln. (d.h. DropPermission wird nur vom überbrückten XWikiCachingRightService unterstützt.)\n\n## Allgemeine API-Schnittstelle\n\nBereitgestellt von Role org.xwiki.security.authorization.AuthorizationManager:\n\n    /\\*\\*  \n     \\* Überprüfen Sie, ob der Benutzer, der durch {@code userReference} identifiziert wird, den Zugriff hat, der durch {@code right} auf die  \n     \\* Entität identifiziert durch {@code entityReference}.  \n     \\* Diese Funktion sollte an Sicherheitskontrollpunkten verwendet werden.  \n     \\*/  \n    void checkAccess(Right right, DocumentReference userReference, EntityReference entityReference)  \n        throws AccessDeniedException;  \n  \n    /\\*\\*  \n     \\* Überprüfen Sie, ob der Benutzer, der durch {@code userReference} identifiziert wird, den Zugriff hat, der durch {@code right} auf die  \n     \\* Entität identifiziert durch {@code entityReference}.  \n     \\* Diese Funktion sollte für Schnittstellenangelegenheiten verwendet werden, verwenden Sie {@link #checkAccess} an Sicherheitskontrollpunkten.  \n     \\*/  \n    boolean hasAccess(Right right, DocumentReference userReference, EntityReference entityReference);  \n  \n    /\\*\\*  \n     \\* Registrieren Sie ein neues benutzerdefiniertes {@link Right}.  \n     \\*/  \n    Right register(RightDescription rightDescription) throws UnableToRegisterRightException;  \n  \n    /\\*\\*  \n     \\* Registrieren Sie ein neues benutzerdefiniertes {@link Right} und fügen Sie es als impliziertes Recht zum gegebenen Satz von Rechten hinzu.  \n     \\*  \n     \\* @param rightDescription die vollständige Beschreibung des neuen {@link Right}  \n     \\* @param impliedByRights die Rechte, die das neue Recht implizieren sollen.  \n     \\* @return das erstellte {@link Right}  \n     \\* @throws UnableToRegisterRightException, wenn ein Fehler die Erstellung des neuen Rechts verhindert. Das Registrieren genau  \n     \\* desselben Rechts verursacht keine Ausnahme und gibt das vorhandene Recht zurück.  \n     \\* @since 12.6  \n     \\*/  \n    Right register(RightDescription rightDescription, Set<Right> impliedByRights) throws UnableToRegisterRightException;  \n  \n    /\\*\\*  \n     \\* Melden Sie das angegebene benutzerdefinierte {@link Right} ab.  \n     \\*  \n     \\* @param right das benutzerdefinierte Recht, das abgemeldet werden soll.  \n     \\* @throws AuthorizationException, wenn das Recht nicht benutzerdefiniert ist.  \n     \\* @since 13.5RC1  \n     \\*/  \n    void unregister(Right right) throws AuthorizationException;## Kontextuelle API-Schnittstelle (seit 6.1RC1)\n\nBereitgestellt von Role org.xwiki.security.authorization.ContextualAuthorizationManager:\n\n    /\\*\\*  \n     \\* Überprüfen Sie, ob der Zugriff, der durch {@code right} auf die aktuelle Entität identifiziert wird, im aktuellen Kontext erlaubt ist.  \n     \\* Diese Funktion sollte an Sicherheitskontrollpunkten verwendet werden.  \n     \\*  \n     \\* @param right das für die Ausführung der Aktion erforderliche Recht  \n     \\* @throws AccessDeniedException, wenn die Aktion verweigert werden sollte, was auch passieren kann, wenn ein Fehler auftritt  \n     \\*/  \n    void checkAccess(Right right) throws AccessDeniedException;  \n  \n    /\\*\\*  \n     \\* Überprüfen Sie, ob der Zugriff, der durch {@code right} auf die aktuelle Entität identifiziert wird, im aktuellen Kontext erlaubt wäre.  \n     \\* Diese Funktion sollte für Schnittstellenangelegenheiten verwendet werden, verwenden Sie {@link #checkAccess} an Sicherheitskontrollpunkten.  \n     \\*  \n     \\* @param right das zu überprüfende Recht.  \n     \\* @return {@code true}, wenn der Benutzer das angegebene Recht auf die Entität hat, {@code false} andernfalls  \n     \\*/  \n    boolean hasAccess(Right right);  \n  \n    /\\*\\*  \n     \\* Überprüfen Sie, ob der Zugriff, der durch {@code right} auf die gegebene Entität identifiziert wird, im aktuellen Kontext erlaubt ist.  \n     \\* Diese Funktion sollte an Sicherheitskontrollpunkten verwendet werden.  \n     \\*  \n     \\* @param right das für die Ausführung der Aktion erforderliche Recht  \n     \\* @param entityReference die Entität, auf der das Recht überprüft werden soll  \n     \\* @throws AccessDeniedException, wenn die Aktion verweigert werden sollte, was auch passieren kann, wenn ein Fehler auftritt  \n     \\*/  \n    void checkAccess(Right right, EntityReference entityReference) throws AccessDeniedException;  \n  \n    /\\*\\*  \n     \\* Überprüfen Sie, ob der Zugriff, der durch {@code right} auf die gegebene Entität identifiziert wird, im aktuellen Kontext erlaubt wäre.  \n     \\* Diese Funktion sollte für Schnittstellenangelegenheiten verwendet werden, verwenden Sie {@link #checkAccess} an Sicherheitskontrollpunkten.  \n     \\*  \n     \\* @param right das zu überprüfende Recht.  \n     \\* @param entityReference die Entität, auf der das Recht überprüft werden soll  \n     \\* @return {@code true}, wenn der Benutzer das angegebene Recht auf die Entität hat, {@code false} andernfalls  \n     \\*/  \n    boolean hasAccess(Right right, EntityReference entityReference);Der Kontext enthält Informationen wie den authentifizierten Benutzer, das aktuell ausgeführte Makro, die Einschränkung des Rendering-Kontexts, das Ablegen von Rechten durch Makro usw.  \nWenn Sie Zweifel haben, welche API Sie verwenden sollen, sollten Sie wahrscheinlich die kontextuelle verwenden, es sei denn, Sie überprüfen wirklich Rechte außerhalb des Kontexts.\n\n## Aktuellen Autor ändern (seit 8.3RC1)\n\nBereitgestellt von Role org.xwiki.security.authorization.AuthorExecutor:\n\n    /\\*\\*  \n     \\* Führen Sie das übergebene {@link Callable} mit den Rechten des übergebenen Benutzers aus.  \n     \\*  \n     \\* @param callable die auszuführende Aufgabe  \n     \\* @param authorReference der Benutzer, auf den Rechte überprüft werden sollen  \n     \\* @return berechnetes Ergebnis  \n     \\* @throws Exception, wenn das Ergebnis nicht berechnet werden kann  \n     \\* @param <V> der Ergebnistyp der Methode <tt>call</tt>  \n     \\*/  \n    <V> V call(Callable<V> callable, DocumentReference authorReference) throws Exception;  \n  \n    /\\*\\*  \n     \\* Richten Sie den Kontext so ein, dass der folgende Code mit den Rechten des angegebenen Benutzers ausgeführt wird.  \n     \\*   \n     \\* <pre>  \n     \\* {@code  \n     \\* try (AutoCloseable context = this.executor.before(author)) {  \n     \\*   ...  \n     \\* }  \n     \\* }  \n     \\* </pre>  \n     \\*  \n     \\* @param authorReference der Benutzer, auf den Rechte überprüft werden sollen  \n     \\* @return der Kontext zur Wiederherstellung  \n     \\* @see #after(AutoCloseable)  \n     \\*/  \n    AutoCloseable before(DocumentReference authorReference);  \n  \n    /\\*\\*  \n     \\* Stellen Sie den Kontext in seinen vorherigen Zustand wieder her, wie durch das bereitgestellte {@link AutoCloseable} definiert.  \n     \\*  \n     \\* @param context der wiederherzustellende Kontext  \n     \\* @see #before(DocumentReference)  \n     \\*/  \n    void after(AutoCloseable context);## Scripting-API (seit 6.1RC1)\n\nBietet Zugriff auf die allgemeine und kontextuelle API aus Skript-Diensten.  \nHier sind einige Beispielcodes:\n\n#if ($services.security.authorization.hasAccess('edit'))  \n... zeigen Sie einige UI, die Bearbeitungszugriff auf das aktuelle Dokument durch den aktuellen Benutzer erfordert ...  \n#end  \n#if ($services.security.authorization.hasAccess('edit', 'xwiki:Sandbox.TestPage1'))  \n... zeigen Sie einige UI, die Bearbeitungszugriff auf das Dokument Sandbox.TestPage1 durch den aktuellen Benutzer erfordert ...  \n#end  \n#if ($services.security.authorization.hasAccess('edit', 'xwiki:XWiki.User1', 'xwiki:Sandbox.TestPage1'))  \n... zeigen Sie einige UI, die Bearbeitungszugriff auf das Dokument Sandbox.TestPage1 durch XWiki.User1 erfordert ...  \n#end$services.security.authorization.checkAccess('edit')  \n... führen Sie eine Aufgabe aus, die Bearbeitungszugriff erfordert ...## Verwendung von checkAccess() versus hasAccess()\n\nBeide Funktionen bieten dieselbe Zugriffskontrolle, unterscheiden sich jedoch in der Art und Weise, wie das Ergebnis gemeldet wird. Während die Methode hasAccess() einfach eine true/false-Antwort liefert, benötigt die Methode checkAccess() keine Rückgabewertüberprüfung, da sie eine AccessDeniedException auslöst, wenn der resultierende Zugriff verweigert wurde.\n\nIm alten Rechtedienst gab es keine Unterscheidung zwischen Zugriffskontrolle für UI-Zwecke und Zugriffskontrolle für die tatsächliche Durchführung von Aktionen. Es wurde nur die Methode hasAccess() bereitgestellt. Das Fehlen dieser Unterscheidung ist nicht gut, weil:\n\n* es nicht ermöglicht, alle kritischen Sicherheitszugriffskontrollpunkte leicht zu finden, an denen der Zugriff zur Gewährleistung der Sicherheit überprüft wird.\n* es die Verantwortung für die ordnungsgemäße Überprüfung der Rückgabewerte durch den Aufrufer an diesen Sicherheitskontrollpunkten belässt.\n* es die Last der Verwaltung von Zugriff verweigert Situationen individuell in all diesen Sicherheitskontrollpunkten durch den Aufrufer belässt.\n\nDaher wird dringend empfohlen, die neue Methode checkAccess() überall dort zu verwenden, wo Sie einen Zugriff vor einer Aktion überprüfen. Und Sie sollten darauf verzichten, die resultierende Ausnahme abzufangen, dies sollte auf höherer Ebene durch die UI erfolgen, die somit in der Lage sein wird, alle Zugriffsverletzungen zentral zu verwalten. (Offensichtlich ist dies ein laufender Prozess, den wir jetzt beginnen und der erst richtig funktioniert, wenn die vollständige Migration des alten Dienstes abgeschlossen ist). Beachten Sie auch, dass Zugriffsverletzungen, die während checkAccess() auftreten, protokolliert werden. In den meisten Situationen sollte dies nicht passieren, da die UI oder früherer Code bereits die Möglichkeit des Zugriffs überprüft hat und keinen Pfad zur verbotenen Aktion bietet. Denken Sie auch daran, dass das mehrfache Überprüfen desselben Zugriffs nicht kostspielig ist, daher ist das Überprüfen des Zugriffs sehr nahe an der Aktion (auch wenn Sie denken, dass es keinen Grund gibt, warum er verweigert werden sollte) eine gute Sicherheitsmaßnahme, um Sicherheitsfehler zu verhindern. Dies ist eindeutig der Zweck der Methode checkAccess().\n\n## Einige Definitionen, wie sie von diesem Modul gesehen werden\n\nEntitätEine *Entität* ist ein Objekt, auf dem einige Aktionen ausgeführt werden können. Es könnte ein Dokument, ein Wiki, ein Raum oder sogar ein XWiki-Objekt oder Eigenschaften sein. Es kann, je nach seiner Natur, andere *Ent"
}