{"id": "dev:IRC.xwikiArchive20160116", "url": "https://dev.xwiki.org/xwiki/bin/view/IRC/xwikiArchive20160116", "title": "IRC Archive for channel #xwiki on 16 January 2016 - XWiki", "collection": "Eval-Large", "mimetype": "text/markdown", "language": "en", "content": "\n<sdumitriu>\u00a0vmassol: I don't think it's a bug, it's a feature  \n00:22\u00a0<sdumitriu>\u00a0(re null in AbstractChainableUberspector)  \n00:25\u00a0<sdumitriu>\u00a0The default behavior is to return null, which means that it will let the previous element in the chain try to resolve the method/iterator/...  \n00:26\u00a0<sdumitriu>\u00a0It's kind of an abstract method, if the uberspector extending the Abstract class wants to look for something, then it must override the method  \n00:27\u00a0<sdumitriu>\u00a0If it were to return super, then the chain would just be the last element in the chain, since it always returns null  \n00:28\u00a0<sdumitriu>\u00a0So, it's the responsibility of the developer defining the configuration to make sure the chain is well defined and will return the things she needs  \n00:29\u00a0<sdumitriu>\u00a0And the chain is defined in the right order, the javadoc says that results are passed from the end of the chain to the front  \n00:30\u00a0<sdumitriu>\u00a0And if one of the links returns null, the following links have a chance to fill in  \n00:33\u00a0<sdumitriu>\u00a0Actually the process is: start at the front, each link should first forward to the next link, then process the result so far (replace, remove), and return back to the previous link  \n00:34\u00a0<lucaa>\u00a0has quit  \n00:34\u00a0<sdumitriu>\u00a0Of course, a link is allowed to not forward first  \n01:32\u00a0<abusenius>\u00a0has quit  \n01:36\u00a0<RodrigoPT76>\u00a0has joined #xwiki  \n01:59\u00a0<vmassol>\u00a0sdumitriu: if the user wants to remove the secure uberspector from the chain, how would he do it?  \n02:00\u00a0<vmassol>\u00a0AFAICS removing the secure uberspector will make the chain fail  \n02:01\u00a0<vmassol>\u00a0(and configuring the chain with a single uberspector fails too)  \n02:02\u00a0<vmassol>\u00a0has quit  \n05:00\u00a0<xwikibot>\u00a0has joined #xwiki  \n05:57\u00a0<RodrigoPT76>\u00a0has quit  \n08:46\u00a0<MasterPiece>\u00a0has joined #xwiki  \n09:28\u00a0<MasterPiece>\u00a0has quit  \n09:30\u00a0<lucaa>\u00a0has joined #xwiki  \n09:58\u00a0<lucaa>\u00a0has quit  \n10:56\u00a0<woshilapin>\u00a0has joined #xwiki  \n10:56\u00a0<abusenius>\u00a0has joined #xwiki  \n11:04\u00a0<vmassol>\u00a0has joined #xwiki  \n11:37\u00a0<woshilapin>\u00a0has quit  \n14:45\u00a0<lucaa>\u00a0has joined #xwiki  \n14:48\u00a0<lucaa>\u00a0has quit  \n14:48\u00a0<lucaa>\u00a0has joined #xwiki  \n15:01\u00a0<Bugen\\_do>\u00a0has quit  \n15:03\u00a0<RodrigoPT76>\u00a0has joined #xwiki  \n15:04\u00a0<lucaa>\u00a0has quit  \n15:04\u00a0<lucaa>\u00a0has joined #xwiki  \n15:08\u00a0<Bugen\\_do>\u00a0has joined #xwiki  \n15:24\u00a0<lucaa>\u00a0has quit  \n15:35\u00a0<lucaa>\u00a0has joined #xwiki  \n15:43\u00a0<lucaa>\u00a0has quit  \n16:08\u00a0<lucaa>\u00a0has joined #xwiki  \n16:26\u00a0<lucaa>\u00a0has quit  \n16:40\u00a0<lucaa>\u00a0has joined #xwiki  \n17:14\u00a0<lucaa>\u00a0has quit  \n17:14\u00a0<lucaa>\u00a0has joined #xwiki  \n17:32\u00a0<lucaa>\u00a0has quit  \n17:43\u00a0<woshilapin>\u00a0has joined #xwiki  \n18:36\u00a0<RodrigoPT76>\u00a0has quit  \n20:23\u00a0<sdumitriu>\u00a0vmassol: Instead of using SecureUbespector, put UberspectImpl in the configuration  \n20:24\u00a0<sdumitriu>\u00a0And using just one uberspector in the chain works, as long as it is an uberspector that does what you want  \n20:24\u00a0<sdumitriu>\u00a0You can't put just DeprecatedCheckUberspector, since that's not an ubespector that resolves requested methods  \n20:25\u00a0<sdumitriu>\u00a0And it's not supposed to do that  \n20:25\u00a0<sdumitriu>\u00a0It's a module  \n20:25\u00a0<sdumitriu>\u00a0Uberspectors are supposed to be modular  \n20:28\u00a0<sdumitriu>\u00a0Again, some can resolve new things, like also allowing public field access, some are supposed to block access to things, like reflection, and some are just supposed to monitor what happens, like warning on deprecated method access  \n20:28\u00a0<sdumitriu>\u00a0And it's the developer's job to make sure the uberspectors chosen make sense  \n20:29\u00a0<sdumitriu>\u00a0So no, putting just a monitoring uberspector is not supposed to work like the secure ubespector was also in place  \n20:30\u00a0<sdumitriu>\u00a0The behavior of the secure uberspector is not \"standard\", it's just one of the possibilities  \n21:08\u00a0<vmassol>\u00a0ok thanks for the explanations sdumitriu. I think it's just too complicated for my brain :) I have the feeling it's more complex than it could be but I could be wrong.  \n21:09\u00a0<vmassol>\u00a0it doesn't click for me for some reason. I remember I spent a long time trying to understand in the past (when I needed to write a unit test) and again I've spent at least 1 hour 2 days ago when I wanted to write a new unit tests for an uberspector and in the end I dropped it and just added a secureubspector in the chain even though it wasn't required for the test  \n21:09\u00a0<vmassol>\u00a0and I see marius has done the same in the past too  \n21:10\u00a0<lucaa>\u00a0has joined #xwiki  \n21:10\u00a0<vmassol>\u00a0anyway I'm not planning to change it. However we need to retrofit the code to use the chaining uberspector feature from velocity. Maybe it'll be a bit different  \n21:24\u00a0<lucaa>\u00a0has quit  \n21:27\u00a0<vmassol>\u00a0OTOH, in the end, I'm happy that I had the SecureUberspector in my test since it allowed me to discover a bug I had in my uberspector ;)\n"}