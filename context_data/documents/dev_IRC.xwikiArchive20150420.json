{"id": "dev:IRC.xwikiArchive20150420", "url": "https://dev.xwiki.org/xwiki/bin/view/IRC/xwikiArchive20150420", "title": "IRC Archive for channel #xwiki on 20 April 2015 - XWiki", "collection": "Eval-Large", "mimetype": "text/markdown", "language": "en", "content": "\n<thomass>\u00a0has joined #xwiki  \n02:16\u00a0<thomass>\u00a0has quit  \n02:17\u00a0<sdumitriu1>\u00a0has joined #xwiki  \n02:19\u00a0<thomass\\_\\_>\u00a0has joined #xwiki  \n02:19\u00a0<thomass\\_\\_>\u00a0has quit  \n02:19\u00a0<thomass>\u00a0has joined #xwiki  \n02:22\u00a0<thomass>\u00a0has quit  \n02:51\u00a0<Chuguniy>\u00a0has quit  \n05:14\u00a0<sdumitriu1>\u00a0has quit  \n06:59\u00a0<msmeria>\u00a0has joined #xwiki  \n07:14\u00a0<DarkKnightCZ>\u00a0has joined #xwiki  \n07:54\u00a0<woshilapin>\u00a0has quit  \n08:19\u00a0<vmassol>\u00a0has joined #xwiki  \n08:43\u00a0<cjd>\u00a0has joined #xwiki  \n08:43\u00a0<woshilapin>\u00a0has joined #xwiki  \n08:45\u00a0<martin-h>\u00a0has quit  \n08:53\u00a0<KermitTheFragger>\u00a0has joined #xwiki  \n08:59\u00a0<Enygma`>\u00a0has joined #xwiki  \n09:00\u00a0<martin-h>\u00a0has joined #xwiki  \n09:46\u00a0<lucaa>\u00a0has joined #xwiki  \n09:54\u00a0<mflorea>\u00a0has joined #xwiki  \n09:57\u00a0<Pbas>\u00a0has joined #xwiki  \n10:04\u00a0<Pbas>\u00a0Hello everyone, someone have some time to watch my PR for http://jira.xwiki.org/browse/XWIKI-6118 issue? Thxs  \n10:07\u00a0<martin-h>\u00a0has quit  \n10:08\u00a0<vmassol>\u00a0has quit  \n10:08\u00a0<vmassol>\u00a0has joined #xwiki  \n10:17\u00a0<martin-h>\u00a0has joined #xwiki  \n10:17\u00a0<Slashman>\u00a0has joined #xwiki  \n10:54\u00a0<gsmeria>\u00a0has joined #xwiki  \n11:09\u00a0<lucaa>\u00a0has quit  \n11:11\u00a0<martin-h>\u00a0has quit  \n11:11\u00a0<lucaa>\u00a0has joined #xwiki  \n11:20\u00a0<martin-h>\u00a0has joined #xwiki  \n12:01\u00a0<vmassol>\u00a0FYI I've documented the new URL Architecture here: http://platform.xwiki.org/xwiki/bin/preview/DevGuide/URL+Architecture  \n12:03\u00a0<cjd>\u00a0preview link  \n12:03\u00a0<cjd>\u00a0http://platform.xwiki.org/xwiki/bin/view/DevGuide/URL+Architecture  \n12:05\u00a0<cjd>\u00a0looks nice  \n12:06\u00a0<vmassol>\u00a0indeed, thanks for fixing the link  \n12:07\u00a0<cjd>\u00a0So I can just URLHandler.map(\"/cjd/\", functionWrappedInObjectBecauseJavaDoesNotSupportFirstClassFunctions); ?  \n12:07\u00a0<cjd>\u00a0or URLHandler.map(\"/cjd/\", myServlet) ?  \n12:07\u00a0<vmassol>\u00a0cjd: yes, not a servlet though, a component class  \n12:08\u00a0<cjd>\u00a0you register a class?  \n12:08\u00a0<cjd>\u00a0as opposed to an object?  \n12:08\u00a0<vmassol>\u00a0cjd: http://extensions.xwiki.org/xwiki/bin/view/Extension/Resource+API#HAddinganewResourceTypeHandler  \n12:09\u00a0<cjd>\u00a0ahh no it's an object  \n12:09\u00a0<cjd>\u00a0why this? \u00a0\u00a0\u00a0\u00a0public static final ResourceType TYPE = new ResourceType(\"webjars\");  \n12:10\u00a0<cjd>\u00a0instead of using: @Named(\"webjars\")  \n12:10\u00a0<vmassol>\u00a0it's not instead  \n12:10\u00a0<vmassol>\u00a0it's in addition  \n12:10\u00a0<vmassol>\u00a0you have to implement getSupportedResourceReferences()  \n12:10\u00a0<cjd>\u00a0can I leave out the public static final ResourceType TYPE = new ResourceType(\"webjars\"); and public List<ResourceType> getSupportedResourceReferences() and have it just use @Named() ?  \n12:11\u00a0<vmassol>\u00a0no  \n12:11\u00a0<vmassol>\u00a0getSupportedResourceReferences() is in the interface  \n12:11\u00a0<vmassol>\u00a0actually I need to change that name it's not correct\u2026 should getSupportedResourceReferenceTypes()  \n12:11\u00a0<vmassol>\u00a0it's all the types supported by this handler  \n12:12\u00a0<cjd>\u00a0yeah, getSupportedResourceReferences is too short :P  \n12:12\u00a0<vmassol>\u00a0indeed  \n12:13\u00a0<cjd>\u00a0shouldn't AbstractResourceReferenceHandler be clever enough to introspect it's class, get the name and provide a default implementation of getSupportedResourceReferences ?  \n12:13\u00a0<cjd>\u00a0\\*get the @Named() name  \n12:13\u00a0<vmassol>\u00a0first a component currently doesn't have access to its metadata. I wanted to implement that but I don't think I've done it yet  \n12:14\u00a0<vmassol>\u00a0actually maybe I did, I don't remember :)  \n12:14\u00a0<cjd>\u00a0hmm  \n12:14\u00a0<vmassol>\u00a0checking quickly  \n12:14\u00a0<vmassol>\u00a0it's done ;)  \n12:15\u00a0<vmassol>\u00a0@Inject private ComponentDescriptor descriptor:  \n12:15\u00a0<vmassol>\u00a0so it's possible indeed to implement a default  \n12:15\u00a0<evalica>\u00a0has joined #xwiki  \n12:16\u00a0<cjd>\u00a0String tryThis() { return this.getClass().getAnnotation(Named.class).value }  \n12:16\u00a0<cjd>\u00a0in the abstract superclass  \n12:16\u00a0<cjd>\u00a0that should do the trick  \n12:16\u00a0<vmassol>\u00a0that's really bad  \n12:16\u00a0<vmassol>\u00a0and hackish  \n12:16\u00a0<cjd>\u00a0objective fact or personal opinion?  \n12:17\u00a0<vmassol>\u00a0for at least 2 reasons: it creates a link with the annotation name and it works only for components registered with annotations  \n12:17\u00a0<vmassol>\u00a0(it'll fail if you register a component dynamically against the CM)  \n12:17\u00a0<vmassol>\u00a0@Inject private ComponentDescriptor descriptor: is made for this  \n12:17\u00a0<cjd>\u00a0reason #2 makes sense  \n12:18\u00a0<cjd>\u00a0but then your impl is no better because it hardcodes the thing into the class  \n12:18\u00a0<cjd>\u00a0so registering it dynamically will never work  \n12:19\u00a0<cjd>\u00a0so actually given reason #2, it seems it is highly valuable to be able to use the metadata :)  \n12:19\u00a0<DarkKnightCZ>\u00a0has quit  \n12:58\u00a0<DarkKnightCZ>\u00a0has joined #xwiki  \n12:58\u00a0<vmassol>\u00a0cjd: you're confusing things. getSupportedResourceReferences() should never be dynamic, that would be plain wrong since the handle() method needs to handle it  \n12:59\u00a0<DarkKnightCZ>\u00a0has quit  \n13:01\u00a0<vmassol>\u00a0(the dynamic part is only for the registration of the component)  \n13:38\u00a0<Denis1>\u00a0has joined #xwiki  \n13:38\u00a0<Denis1>\u00a0is now known as <Denis>  \n13:41\u00a0<cjd>\u00a0vmassol: it's either one or the other, if hardcoding it in the @Named() is no good then neither is hardcoding it in the public static final ResourceType TYPE field.  \n13:41\u00a0<vmassol>\u00a0you still don't get it :)  \n13:41\u00a0<cjd>\u00a0hehe  \n13:42\u00a0<cjd>\u00a0yeah, I think I understand  \n13:42\u00a0<vmassol>\u00a0annotations are only statically to register components  \n13:42\u00a0<vmassol>\u00a0when you register a component dynamocally (ie at runtime)  \n13:42\u00a0<vmassol>\u00a0then annotations are not used  \n13:42\u00a0<vmassol>\u00a0you provide a component descriptor to perform the registration  \n13:42\u00a0<vmassol>\u00a0thus if there's some code in a component that assume that an annotation exists, it'll fail  \n13:43\u00a0<vmassol>\u00a0or you'll need to maintain both places: i.e. the annotation + the component desciprtor  \n13:43\u00a0<cjd>\u00a0however, it does help to once in a while admit that you are wrong because statistically everyone is wrong sometimes so if someone never admits that their idea was bunk, the default assumption has to be that they will never accept that anything they did was a bad idea  \n13:43\u00a0<vmassol>\u00a0sorry what's the question? :)  \n13:44\u00a0<vmassol>\u00a0(to which i need to admit that I was wrong)  \n13:44\u00a0<cjd>\u00a0No offense or anything, just that if I have good memories of you saying \"oops no, that was a bad idea, I will revert\" then I will listen to your arguments more carefully  \n13:44\u00a0<vmassol>\u00a0not srue what you're getting at  \n13:45\u00a0<vmassol>\u00a0I think you've not read me corretly  \n13:45\u00a0<vmassol>\u00a0read above  \n13:45\u00a0<vmassol>\u00a0and look for th place that says that \"I agree that we could do this\"  \n13:45\u00a0<vmassol>\u00a0now I cannot agree to all the things you said that are not correct obviously so I cannot agree to everything ;)  \n13:46\u00a0<cjd>\u00a0haha I like that line  \n13:46\u00a0<vmassol>\u00a0the line was \"so it's possible indeed to implement a default\"  \n13:46\u00a0<vmassol>\u00a0if that's your question  \n13:46\u00a0<vmassol>\u00a0again I'm unclear to what I should recognize that I was wrong here  \n13:47\u00a0<cjd>\u00a0maybe you're exactly right  \n13:47\u00a0<vmassol>\u00a0FTR I'm wrong several times a day :)  \n13:47\u00a0<vmassol>\u00a0if the question is: we should read the @Named annotation in the component code, than I maintain that it's a terrible idea :)  \n13:47\u00a0<vmassol>\u00a0\\*then  \n13:48\u00a0<cjd>\u00a0well argument #2 doesn't exactly hold because we're not going to be dynamically registering anyway  \n13:48\u00a0<cjd>\u00a0I mean we might but using a statically defined field is the same as a statically defined annotation  \n13:48\u00a0<vmassol>\u00a0so your point is that parsing manually the @Named annotation is better than using the @Inject ComponentDescriptor?  \n13:49\u00a0<vmassol>\u00a0(as you can see i'm really confused by what you're trying to prove here)  \n13:50\u00a0<vmassol>\u00a0btw  \n13:50\u00a0<cjd>\u00a0well @Named() is nicer for the end user (developer)  \n13:50\u00a0<vmassol>\u00a0the @Named annotation value has nothing to see with the Resource Types that should be handled :)  \n13:51\u00a0<cjd>\u00a0because it \"just works\" unless they override it  \n13:51\u00a0<vmassol>\u00a0it just happens in this specific example I gave that I've used the same value but it's pure coincidence  \n13:51\u00a0<vmassol>\u00a0cjd: @Inject ComponentDescriptor just works  \n13:51\u00a0<vmassol>\u00a0(for all cases)  \n13:52\u00a0<vmassol>\u00a0except that it's bad idea I think because the Resource Types and the component hint are othogonal  \n13:52\u00a0<cjd>\u00a0I think that statement requires justification  \n13:53\u00a0<cjd>\u00a0they're two strings, each of which are in a collision domain, so if url component collides or if CM name collides, badThings(tm)  \n13:53\u00a0<cjd>\u00a0merging them seems a logical thing to do unless there is solid reason to avoid it  \n13:54\u00a0<vmassol>\u00a0need to check something in the code, I don't remember how I do something and I might have a bug  \n13:55\u00a0<cjd>\u00a0I would go as far as to say that one \\*must\\* be the same as the other, and if there needs to be multiple then we'll handle that bridge when we burn it  \n13:56\u00a0<martin-h>\u00a0has quit  \n13:57\u00a0<vmassol>\u00a0no it works, pfew :)  \n13:57\u00a0<vmassol>\u00a0so I confirm that the resource handler component hint has nothing to do with handled resource types  \n13:58\u00a0<vmassol>\u00a0the hint uses by a resource handler component is just a unique name that is not used, meant to differentiate it from other components implementing the same role interfgace  \n13:58\u00a0<vmassol>\u00a0\\*interface  \n13:58\u00a0<vmassol>\u00a0what's important is getSupportedResourceReferences()  \n13:58\u00a0<vmassol>\u00a0and this is what tells the ResourceHandlerManager component what a given Resource Handler can handle  \n13:59\u00a0<cjd>\u00a0I don't see any reason not to link SRRT's and hint name, doing so is Convention over Configuration  \n14:00\u00a0<cjd>\u00a0\"works by default\"  \n14:00\u00a0<vmassol>\u00a0the reason is that they're completely orthogonal so there's no reason to use it for that  \n14:00\u00a0<vmassol>\u00a0that's why there's a getSupportedResourceReferences() method  \n14:01\u00a0<cjd>\u00a013:59 <@vmassol> the reason is that ... there's no reason <-- I understand you but \"no reason is the reason\" is not the most compelling argument  \n14:02\u00a0<vmassol>\u00a0it's the opposite caleb  \n14:02\u00a0<vmassol>\u00a0when you wish to related 2 unrelated stuff you need a strong argument  \n14:02\u00a0<vmassol>\u00a0\\*relate  \n14:02\u00a0<vmassol>\u00a0linking them would just create confusion and imply they're lated  \n14:02\u00a0<vmassol>\u00a0$related  \n14:02\u00a0<vmassol>\u00a0\\*related  \n14:02\u00a0<cjd>\u00a0the relationship is they're both identifiers for the same object  \n14:03\u00a0<vmassol>\u00a0I personnally prefer clarity ad 3 more lines  \n14:03\u00a0<vmassol>\u00a0\\*and  \n14:03\u00a0<vmassol>\u00a0btw  \n14:04\u00a0<vmassol>\u00a0we could imagine  \n14:04\u00a0<vmassol>\u00a0an improvement in the Component Manager  \n14:04\u00a0<vmassol>\u00a0so that we don't have to use a @Named if we don't care about it  \n14:04\u00a0<vmassol>\u00a0and internally the CM would just use some random id  \n14:04\u00a0<martin-h>\u00a0has joined #xwiki  \n14:05\u00a0<cjd>\u00a0anonymous components?  \n14:05\u00a0<vmassol>\u00a0(we would need a standard for the default hint though - Sergiu had a proposal for this too)  \n14:05\u00a0<vmassol>\u00a0yes something like that  \n14:05\u00a0<cjd>\u00a0at first glance that sounds like a sort of memory leak factory  \n14:05\u00a0<vmassol>\u00a0:)  \n14:06\u00a0<vmassol>\u00a0I tend to agree :)  \n14:06\u00a0<cjd>\u00a0ahh, you're picking up the trick ;)  \n14:07\u00a0<Slashman>\u00a0has quit  \n14:28\u00a0<Trefex>\u00a0has joined #xwiki  \n14:28\u00a0<Slashman>\u00a0has joined #xwiki  \n14:50\u00a0<woshilapin>\u00a0Hi devs, I'm currently working with the packager plugin which is great  \n14:51\u00a0<woshilapin>\u00a0I'm wondering if I can also configure some of the XWiki properties  \n14:51\u00a0<woshilapin>\u00a0like superadmin password for example  \n14:51\u00a0<woshilapin>\u00a0This is my POM at the moment  \n14:51\u00a0<woshilapin>\u00a0https://ezcrypt.it/RqAn#h854PuPTfnz2PWxU0BoljT2m  \n14:52\u00a0<vmassol>\u00a0woshilapin: hi  \n14:52\u00a0<vmassol>\u00a0yes you can pass the superadmin password  \n14:52\u00a0<woshilapin>\u00a0Hi vmassol, how can I do that in the pom.xml  \n14:53\u00a0<vmassol>\u00a0you should check xwiki.cfg.vm  \n14:53\u00a0<woshilapin>\u00a0Because I'm not sure where to look to find the information  \n14:53\u00a0<vmassol>\u00a0and any property in there can be defined in your pom.xml  \n14:53\u00a0<woshilapin>\u00a0as <property> ?  \n14:53\u00a0<vmassol>\u00a0for example you'll see:  \n14:53\u00a0<vmassol>\u00a0xwiki.superadminpassword=$xwikiCfgSuperadminPassword  \n14:53\u00a0<vmassol>\u00a0which means you can have in your pom, inside <properties>:  \n14:54\u00a0<vmassol>\u00a0<xwikiCfgSuperadminPassword>pass</xwikiCfgSuperadminPassword>  \n14:54\u00a0<vmassol>\u00a0(for eample)  \n14:54\u00a0<vmassol>\u00a0\\*example  \n14:54\u00a0<woshilapin>\u00a0OK, I'll try that  \n14:54\u00a0<woshilapin>\u00a0Thanks  \n14:54\u00a0<vmassol>\u00a0if you need to check the code it's in PackageMojo.java in createVelocityContext()  \n14:55\u00a0<woshilapin>\u00a0OK  \n14:55\u00a0<vmassol>\u00a0woshilapin: here's an example: https://github.com/xwiki/xwiki-platform/blob/master/xwiki-platform-core/xwiki-platform-activeinstalls/xwiki-platform-activeinstalls-test/xwiki-platform-activeinstalls-test-tests/pom.xml  \n14:56\u00a0<woshilapin>\u00a0Yes, I found them but when I tried, it doesn't work  \n14:56\u00a0<woshilapin>\u00a0So I'll retry harder, making sure I've not done something wrong :-)  \n15:04\u00a0<msmeria>\u00a0has quit  \n15:04\u00a0<woshilapin>\u00a0OK, I made a guess on Maven which was not true (I put the property in the parent POM of the distribution I was trying to compile, I thought that the property was transfer to all childs POM)  \n15:05\u00a0<woshilapin>\u00a0tl;dr; It works, thanks  \n15:05\u00a0<vmassol>\u00a0cool  \n15:05\u00a0<vmassol>\u00a0you can configure this  \n15:05\u00a0<vmassol>\u00a0any property is inherited from parent  \n15:05\u00a0<vmassol>\u00a0but  \n15:05\u00a0<vmassol>\u00a0if you redefine it in the children you need to tell maven if it needs to also merge parent stuff  \n15:05\u00a0<vmassol>\u00a0by default it overwrites, not merge  \n15:06\u00a0<woshilapin>\u00a0It was not defined in the child, only in the parent  \n15:06\u00a0<vmassol>\u00a0to merge you need to specify: combine.children=\"append\"  \n15:06\u00a0<woshilapin>\u00a0Anyway, I had also another thing that may have cause the problem  \n15:06\u00a0<vmassol>\u00a0if it's in the parent then it's inherited  \n15:06\u00a0<vmassol>\u00a0you can verify with  \n15:06\u00a0<vmassol>\u00a0mvn help:effective-pom  \n15:06\u00a0<woshilapin>\u00a0ok  \n15:10\u00a0<woshilapin>\u00a0ok, inheritence works well (I've just made other mistakes before)  \n15:10\u00a0<woshilapin>\u00a0:-)  \n15:10\u00a0<woshilapin>\u00a0Now, I'll use the packager on other projects :-)  \n15:10\u00a0<vmassol>\u00a0ok cool  \n15:20\u00a0<sdumitriu1>\u00a0has joined #xwiki  \n15:24\u00a0<Pbas>\u00a0has quit  \n15:51\u00a0<gsmeria>\u00a0has quit  \n16:15\u00a0<Pbas>\u00a0has joined #xwiki  \n16:47\u00a0<gsmeria>\u00a0has joined #xwiki  \n16:51\u00a0<vmassol>\u00a0just updated (and simplified) the Architecture page at http://platform.xwiki.org/xwiki/bin/view/DevGuide/Architecture  \n16:51\u00a0<vmassol>\u00a0I hope you like it  \n16:52\u00a0<vmassol>\u00a0(some diagrams would be nice)  \n17:09\u00a0<cjd>\u00a0vmassol: do you know if XWiki Rights system fits the definition of NIST Role Based Access Control ?  \n17:09\u00a0<cjd>\u00a0because it seems to from looking at the spec  \n17:12\u00a0<vmassol>\u00a0cjd: no idea. I don't know this concept of NIST RBAC  \n17:12\u00a0<vmassol>\u00a0I'm pretty sure it wasn't designed to be  \n17:12\u00a0<cjd>\u00a0well... \u00a0I think we reinvented it xD  \n17:12\u00a0<cjd>\u00a0RBAC defines Subject, Role and Operation to be definable (subject is user)  \n17:13\u00a0<vmassol>\u00a0we don't have Roles ATM  \n17:13\u00a0<vmassol>\u00a0only groups  \n17:13\u00a0<cjd>\u00a0do you know what is the difference?  \n17:13\u00a0<cjd>\u00a0because I could not find one  \n17:14\u00a0<vmassol>\u00a0for example JIRA uses both  \n17:14\u00a0<cjd>\u00a0we have User, Group and a set of hardcoded operations (view,register,admin) which would seem to be in violation of the configurable consept of Operation, however our groups can contain groups so we can do wildly complex things fairly easily  \n17:15\u00a0<vmassol>\u00a0we discussed roles in th past AFAIR  \n17:15\u00a0<MasterPiece>\u00a0has joined #xwiki  \n17:15\u00a0<cjd>\u00a0if there's a fundimental difference between a group and a role (at the enforcement engine level) then of course we need to implement them but if there isn't then that could be interesting  \n17:16\u00a0<cjd>\u00a0NIST compliance with only changing a user interface component  \n17:17\u00a0<cjd>\u00a0if people are looking to buy NIST compliance, 64mn$ question :)  \n17:17\u00a0<vmassol>\u00a0would need to read again this thread: http://markmail.org/message/qlfwaze47bq3gtrh  \n17:17\u00a0<cjd>\u00a0mmm thanks  \n17:18\u00a0<cjd>\u00a0Denis's engine seems to be fast and is getting stable so it might be time to start really showcasing our permissions infra  \n17:18\u00a0<vmassol>\u00a0would be nice to have the redesigned Rights UI to showcase it  \n17:18\u00a0<vmassol>\u00a0http://design.xwiki.org/xwiki/bin/view/Improvements/Rights3AProposal shows some roles  \n17:21\u00a0<Denis>\u00a0all this remind me that we have never inverted the way implied rights are provided (actually the resposibility of the implying right in place of being the one of the implied right)  \n17:22\u00a0<cjd>\u00a0I don't understand, can you give an example ?  \n17:25\u00a0<Denis>\u00a0actually, admin right implies view, edit, \u2026, and this is the admin right that define that once for all, would be better if the view (edit, \u2026) rights tells it is implied when you has admin right  \n17:25\u00a0<cjd>\u00a0ahh ok, so mostly an internal matter  \n17:26\u00a0<Denis>\u00a0no so internal, since actually you cannot add a new right that gets implied by admin right  \n17:26\u00a0<cjd>\u00a0hmm I see  \n17:26\u00a0<Denis>\u00a0since you may dynamically add right with a simple extension, it is a bit annoying  \n17:27\u00a0<cjd>\u00a0adding new rights could be interesting because we could do hasAccessLevel() on them in code  \n17:27\u00a0<Denis>\u00a0I realize this design fault too late, it was in the initial design from Andrea, and I have not catch it  \n17:28\u00a0<Denis>\u00a0adding new right works, but adding those right as implied to other existing one don't  \n17:28\u00a0<cjd>\u00a0/nod \u00a0how about adding rights without writing any code ?  \n17:29\u00a0<cjd>\u00a0Right Within Minutes ?  \n17:29\u00a0<Denis>\u00a0you just have to register them, it is declarative  \n17:29\u00a0<cjd>\u00a0so we could imagine a right registerer which runs a query for XObjects of a certain type and registers them all  \n17:29\u00a0<Denis>\u00a0now, the UI should be adapted to use them of course  \n17:30\u00a0<Denis>\u00a0you could, yes  \n17:31\u00a0<Denis>\u00a0there is a hard limit however, of 64 rights registered in given running JVM  \n17:32\u00a0<Denis>\u00a0you can unregister and re-register the same right many times, but only 64 at most  \n17:32\u00a0<Denis>\u00a064 different right at most  \n17:32\u00a0<vmassol>\u00a0this is just an impl limitation AFAIK Denis, right?  \n17:32\u00a0<Denis>\u00a0yes  \n17:32\u00a0<vmassol>\u00a0(bit shitfing or something like this  \n17:32\u00a0<vmassol>\u00a0)  \n17:33\u00a0<Denis>\u00a0bit storing  \n17:34\u00a0<Denis>\u00a0bit get allocated on the fly, but forever for a given right during a given run  \n17:34\u00a0<cjd>\u00a0it's certainly clever  \n17:34\u00a0<Denis>\u00a0while a impl limitation, it is also important for performance  \n17:35\u00a0<Denis>\u00a0IMO, 64 right for a human, is a lot !  \n17:35\u00a0<Denis>\u00a0(I mean in term of management)  \n17:35\u00a0<cjd>\u00a0paranoia knows no bounds ;)  \n17:36\u00a0<Bugen\\_do>\u00a0has joined #xwiki  \n17:36\u00a0<cjd>\u00a0does it precalculate the permission/user matrix in advance, collapsing all of the groups ?  \n17:36\u00a0<cjd>\u00a0aka is isUserInGroup() still expensive ?  \n17:37\u00a0<vmassol>\u00a0reminds me of all the prophecies around memory or computers\u2026.  \n17:37\u00a0<vmassol>\u00a0like there be no more than 10 computers needed in all the world  \n17:37\u00a0<cjd>\u00a0it should be no real problem to fix, we'll just start using a proper bitset  \n17:38\u00a0<cjd>\u00a0which is backed by an array of int64  \n17:38\u00a0<cjd>\u00a0so it expands as needed  \n17:39\u00a0<Denis>\u00a0well, there is several level of optimizations, if you want to know more, a call could be faster :)  \n17:41\u00a0<cjd>\u00a0I don't want to waste too much time unless we have decided we want to do something  \n17:45\u00a0<cjd>\u00a0anyway a concrete question is \"from a performance point of view, should I prefer to define a new right over creating a group and checking permission in the code using isUserInGroup() ?\"  \n17:47\u00a0<Denis>\u00a0The answer is not so simple, but it is a balance. To explain it fast, all rights (the bitset) are evaluated all at the same time for a given user/entity relation. The cache store the hierarchy of involved rules see so far, the user and group membership of involved user so far, and the evaluated bitsets.  \n17:47\u00a0<Denis>\u00a0So asking a different right for the same couple, is a cache hit  \n17:48\u00a0<cjd>\u00a0ok  \n17:48\u00a0<Denis>\u00a0asking a document in the same space, will only require rules from that document, and a new eval, while the rest will came from the cache  \n17:49\u00a0<cjd>\u00a0so we can implement \"pseudo-rights\" using groups and then checking isUserInGroup() without an enormous perf hit ?  \n17:49\u00a0<Denis>\u00a0but at the same time, changing the XWiki.XWikiPreferences document, will lead in a full cache flush !  \n17:49\u00a0<cjd>\u00a0which is fine because it never happens :)  \n17:50\u00a0<Denis>\u00a0isUserInGroup() does not involve the security module at all, and I doubt it works properly  \n17:50\u00a0<Denis>\u00a0I mean it only check the group, not sub groups  \n17:50\u00a0<cjd>\u00a0ok so then it's certainly a database hit so we should avoid it  \n17:50\u00a0<Denis>\u00a0there is an old group cache  \n17:51\u00a0<cjd>\u00a0ok then we should put a /!\\DANGER/!\\ flag over that one :)  \n17:51\u00a0<Denis>\u00a0that is still very useful anyway, since the security cache does not old the whole picture  \n17:51\u00a0<cjd>\u00a0ok  \n17:51\u00a0<cjd>\u00a0thanks  \n17:52\u00a0<Denis>\u00a0the GroupService which use that group cache does not manage group in groups  \n17:52\u00a0<Denis>\u00a0it just report gourps in groups as being members like uses  \n17:52\u00a0<Denis>\u00a0s/uses/users  \n17:52\u00a0<cjd>\u00a0oh actually we can create a faux document for representing a right, weird as it is  \n17:53\u00a0<cjd>\u00a0if you can view document X, code in document Y will let you pass  \n17:53\u00a0<cjd>\u00a0anyway I'll stop wasting your time, thanks for the explanation.  \n17:53\u00a0<Denis>\u00a0quite efficient indeed, but really weird  \n17:58\u00a0<KermitTheFragger>\u00a0has quit  \n18:15\u00a0<Trefex>\u00a0has quit  \n18:28\u00a0<cjd>\u00a0has quit  \n19:02\u00a0<lucaa>\u00a0has quit  \n19:17\u00a0<Slashman>\u00a0has quit  \n19:32\u00a0<Slashman>\u00a0has joined #xwiki  \n20:02\u00a0<Slashman>\u00a0has quit  \n20:30\u00a0<vmassol>\u00a0has quit  \n21:22\u00a0<Bugen\\_do>\u00a0has quit  \n22:52\u00a0<gsmeria>\u00a0has quit  \n22:52\u00a0<mflorea>\u00a0has quit  \n23:27\u00a0<evalica>\u00a0has quit\n"}